<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto Encoding Detection & Decoder</title>
    <meta name="description" content="다양한 인코딩 형식(UTF-8, EUC-KR, Base64, URL 인코딩 등)을 자동으로 감지하고 변환하는 무료 온라인 도구입니다.">
    <meta name="keywords" content="Encoding, Decoding, UTF-8, EUC-KR, Base64, URL 인코딩, 텍스트 변환, 한글 인코딩">
    <meta name="author" content="lettuce">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://yuchulho.github.io/decodeall/">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://yuchulho.github.io/decodeall/">
    <meta property="og:title" content="자동 인코딩 감지 & 디코더">
    <meta property="og:description" content="다양한 인코딩 형식을 자동으로 감지하고 변환하는 무료 온라인 도구">
    <meta property="og:locale" content="ko_KR">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary">
    <meta property="twitter:url" content="https://yuchulho.github.io/decodeall/">
    <meta property="twitter:title" content="자동 인코딩 감지 & 디코더">
    <meta property="twitter:description" content="다양한 인코딩 형식을 자동으로 감지하고 변환하는 무료 온라인 도구">
    <!-- Material UI CDN -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
    <style>
        :root {
            /* CSS 변수로 중복 색상 관리 */
            --primary-color: #1976d2;
            --primary-bg: #e3f2fd;
            --light-bg: #fafdff;
            --light-gray: #f5f7fa;
            --border-color: #e0e0e0;
            --text-secondary: #888;
            --shadow-light: 0 2px 12px 0 rgba(25,118,210,0.08);
        }
        
        body {
            font-family: 'Roboto', Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            min-height: 100vh;
        }
        
        #root {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
        }
        
        /* JSON/XML 구문 강조 */
        .json-key { color: #ffb300; }
        .json-string { color: #43a047; }
        .json-number { color: #29b6f6; }
        .json-boolean { color: #f06292; }
        .json-null { color: #bdbdbd; }
        .xml-tag { color: #64b5f6; }
        .xml-attr { color: #ffd54f; }
        .xml-attr-value { color: #81c784; }
        
        /* 드래그 앤 드롭 공통 스타일 */
        .drag-overlay {
            pointer-events: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            border: 2.5px dashed var(--primary-color);
            background: rgba(25, 118, 210, 0.10);
            z-index: 10;
            transition: border 0.2s, background 0.2s;
            box-sizing: border-box;
        }
        
        .drag-message {
            color: var(--primary-color);
            font-weight: 600;
            font-size: 20px;
            background: rgba(255,255,255,0.85);
            border-radius: 6px;
            padding: 18px 36px;
            box-shadow: var(--shadow-light);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* 모바일 반응형 스타일 */
        @media (max-width: 768px) {
            #root {
                align-items: flex-start;
                padding: 16px 8px;
            }
            .mobile-paper {
                padding: 20px 16px !important;
            }
            .mobile-title {
                font-size: 1.5rem !important;
                margin-bottom: 16px !important;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- i18next and react-i18next -->
    <script src="https://unpkg.com/i18next@23.7.6/dist/umd/i18next.min.js"></script>
    <script src="https://unpkg.com/react-i18next@13.5.0/dist/umd/react-i18next.min.js"></script>
    <!-- Material UI -->
    <script src="https://unpkg.com/@mui/material@5.15.15/umd/material-ui.development.js"></script>
    <!-- GSAP CDN -->
    <script src="https://unpkg.com/gsap@3.12.5/dist/gsap.min.js"></script>
    <!-- iconv-lite for charset decoding (browserified) -->
    <script src="https://cdn.jsdelivr.net/npm/iconv-lite@0.6.3/dist/iconv-lite.min.js"></script>
    <!-- CBOR decoder/encoder library -->
    <script src="https://cdn.jsdelivr.net/npm/cbor-js@0.1.0/cbor.min.js"></script>
    <!-- file-type 라이브러리 (이미지 판별용) - 다른 CDN 시도 -->
    <script src="https://unpkg.com/file-type@19/dist/index.umd.js"></script>
    <script>
        // 라이브러리 초기화 확인
    </script>
    <script>

        // -------------------------
        // 공통 스타일 정의
        // -------------------------
        
        // Material-UI 공통 스타일
        const commonStyles = {
            // 모바일 대응 폰트 크기
            responsiveFont: {
                fontSize: { xs: '0.95rem', md: '0.875rem' },
                lineHeight: { xs: 1.4, md: 1.43 }
            },
            
            // 모바일 대응 라벨 폰트
            responsiveLabel: {
                fontSize: { xs: '1rem', md: '0.875rem' }
            },
            
            // 작은 버튼 스타일
            smallButton: {
                fontSize: { xs: '0.875rem', md: '0.8125rem' },
                padding: { xs: '8px 16px', md: '6px 12px' },
                verticalAlign: 'middle'
            },
            
            // 칩 스타일
            chip: {
                fontSize: { xs: '0.75rem', md: '0.75rem' },
                height: { xs: 26, md: 24 },
                '& .MuiChip-label': {
                    paddingLeft: { xs: 6, md: 8 },
                    paddingRight: { xs: 6, md: 8 },
                    fontSize: { xs: '0.75rem', md: '0.75rem' }
                }
            },
            
            // 탭 스타일
            tab: {
                fontSize: { xs: '0.95rem', md: '0.875rem' },
                fontWeight: { xs: 600, md: 500 },
                minHeight: { xs: 48, md: 48 },
                padding: { xs: '12px 20px', md: '6px 12px' }
            },
            
            // 드래그 오버 배경
            dragBackground: (isDragOver) => ({
                marginBottom: '20px',
                background: isDragOver ? '#e3f2fd' : '#fafdff',
                borderRadius: 2,
                transition: 'background 0.2s'
            }),
            
            // 입력 필드 스타일
            inputField: {
                '& .MuiInputLabel-root': {
                    fontSize: { xs: '1rem', md: '0.875rem' }
                },
                '& .MuiInputBase-input': {
                    fontSize: { xs: '0.95rem', md: '0.875rem' },
                    lineHeight: { xs: 1.4, md: 1.43 }
                }
            },
            
            // 바이트 카운터 스타일
            byteCounter: {
                position: 'absolute',
                right: 16,
                bottom: 10,
                fontSize: 13,
                color: '#888',
                background: '#fafdff',
                padding: '0 6px'
            }
        };

        // 상수 정의
        const MATERIAL_ICON_UPLOAD = "file_upload";
        const {
            Box,
            Typography,
            TextField,
            Paper,
            Grid,
            Divider,
            Chip,
            Tooltip,
            IconButton,
            Tabs,
            Tab,
            FormControl,
            InputLabel,
            Select,
            MenuItem
        } = MaterialUI;

        // -------------------------
        // 통합 유틸리티 함수
        // -------------------------
        
        // 문자열 바이트 길이 계산
        function bytesLen(str) {
            try { 
                return new TextEncoder().encode(str || '').length; 
            } catch { 
                return (str || '').length; 
            }
        }
        
        // 바이너리 문자열 감지
        function isBinaryString(str, threshold = 0.2) {
            if (!str) return false;
            let nonPrintable = 0;
            for (let i = 0; i < str.length; ++i) {
                const code = str.charCodeAt(i);
                if ((code < 0x09 || (code > 0x0D && code < 0x20) || code === 0x7F)) nonPrintable++;
            }
            return (nonPrintable / str.length) > threshold;
        }
        
        // 바이너리 문자열을 Hex View로 변환
        function toHexView(binaryStr) {
            const bytes = binaryStr ? Array.from(binaryStr).map(c => c.charCodeAt(0)) : [];
            let lines = [];
            for (let i = 0; i < bytes.length; i += 16) {
                let hex = bytes.slice(i, i + 16).map(b => b.toString(16).padStart(2, '0')).join(' ');
                let ascii = bytes.slice(i, i + 16).map(b => (b >= 32 && b <= 126 ? String.fromCharCode(b) : '.')).join('');
                lines.push(hex.padEnd(16 * 3) + '  ' + ascii);
            }
            return lines.join('\n');
        }
        
        // -------------------------
        // 바이너리 변환 유틸리티
        // -------------------------
        
        // Base64 문자열을 Uint8Array로 변환
        function base64ToUint8(base64Str) {
            const binaryStr = atob(base64Str.replace(/\s/g, ''));
            const bytes = new Uint8Array(binaryStr.length);
            for (let i = 0; i < binaryStr.length; i++) {
                bytes[i] = binaryStr.charCodeAt(i) & 0xFF;
            }
            return bytes;
        }
        
        // Uint8Array를 바이너리 문자열로 변환
        function uint8ToBinString(uint8Array) {
            let binaryString = '';
            for (let i = 0; i < uint8Array.length; i++) {
                binaryString += String.fromCharCode(uint8Array[i] & 0xFF);
            }
            return binaryString;
        }
        
        // 바이너리 문자열을 Uint8Array로 변환
        function binStringToUint8(binaryStr) {
            const bytes = new Uint8Array(binaryStr.length);
            for (let i = 0; i < binaryStr.length; i++) {
                bytes[i] = binaryStr.charCodeAt(i) & 0xFF;
            }
            return bytes;
        }
        
        // 바이너리 문자열을 Base64로 변환
        function binaryStringToBase64(binStr) {
            const bytes = Uint8Array.from(Array.from(binStr).map(ch => ch.charCodeAt(0)));
            let binary = '';
            bytes.forEach(b => binary += String.fromCharCode(b));
            return btoa(binary);
        }
        
        // -------------------------
        // 파일 처리 유틸리티
        // -------------------------
        function downloadTextFile(content, filename = 'decoded_result.txt') {
            try {
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                return true;
            } catch (error) {
                return false;
            }
        }

        // 바이너리 파일 다운로드 함수 (CBOR 등 바이너리 데이터용)
        function downloadBinaryFile(binaryString, filename = 'binary_result.bin') {
            try {
                // 바이너리 문자열을 Uint8Array로 변환
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i) & 0xFF;
                }
                
                const blob = new Blob([bytes], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                return true;
            } catch (error) {
                return false;
            }
        }
        // 통합 파일 처리 함수
        async function handleFileDrop(e, setValue) {
            e.preventDefault();
            e.stopPropagation();
            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                const file = e.dataTransfer.files[0];
                await processFile(file, setValue);
            }
        }
        
        // 파일 선택 함수
        function handleFileSelect(setValue) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '*/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    await processFile(file, setValue);
                }
            };
            input.click();
        }
        
        // 공통 파일 처리 로직
        async function processFile(file, setValue) {
            if (file.type.startsWith('text/')) {
                const text = await file.text();
                setValue(text);
            } else {
                // 바이너리 파일: 바이너리 문자열 로딩
                const arrayBuffer = await file.arrayBuffer();
                const bytes = new Uint8Array(arrayBuffer);
                let binaryString = '';
                for (let i = 0; i < bytes.length; ++i) {
                    binaryString += String.fromCharCode(bytes[i] & 0xFF);
                }
                setValue(binaryString);
            }
        }
        
        // 이미지 판별 및 Data URL 생성 (file-type 라이브러리 + fallback)
        async function sniffImage(binaryStr) {
            if (!binaryStr) {
                return null;
            }
            
            try {
                // binaryString을 Uint8Array로 변환
                const uint8Array = new Uint8Array(binaryStr.length);
                for (let i = 0; i < binaryStr.length; i++) {
                    uint8Array[i] = binaryStr.charCodeAt(i);
                }
                
                const firstBytes = Array.from(uint8Array.slice(0, 10));
                
                // file-type 라이브러리 시도
                if (typeof window.fileType !== 'undefined' && window.fileType && window.fileType.fileTypeFromBuffer) {
                    const fileType = await window.fileType.fileTypeFromBuffer(uint8Array);
                    
                    if (fileType && fileType.mime && fileType.mime.startsWith('image/')) {
                        return { 
                            mime: fileType.mime, 
                            ext: fileType.ext 
                        };
                    }
                }
                
                // Fallback: 수동 시그니처 검사
                // PNG 시그니처 확인 - 정확한 패턴만 검사
                // 정상 PNG: 89 50 4E 47 0D 0A 1A 0A
                if (firstBytes[0] === 0x89 && firstBytes[1] === 0x50 && 
                    firstBytes[2] === 0x4E && firstBytes[3] === 0x47 &&
                    firstBytes[4] === 0x0D && firstBytes[5] === 0x0A &&
                    firstBytes[6] === 0x1A && firstBytes[7] === 0x0A) {
                    return { mime: 'image/png', ext: 'png' };
                }
                
                // JPEG: FF D8
                if (firstBytes[0] === 0xFF && firstBytes[1] === 0xD8) {
                    return { mime: 'image/jpeg', ext: 'jpg' };
                }
                
                // GIF: 47 49 46 38 (GIF8)
                if (firstBytes[0] === 0x47 && firstBytes[1] === 0x49 && firstBytes[2] === 0x46 && firstBytes[3] === 0x38) {
                    return { mime: 'image/gif', ext: 'gif' };
                }
                
                // BMP: 42 4D
                if (firstBytes[0] === 0x42 && firstBytes[1] === 0x4D) {
                    return { mime: 'image/bmp', ext: 'bmp' };
                }
                
                // SVG: 텍스트 기반이므로 문자열 검사
                if (binaryStr.trim().startsWith('<svg')) {
                    return { mime: 'image/svg+xml', ext: 'svg' };
                }
                
                return null;
                
            } catch (error) {
                return null;
            }
        }

        // CBOR 디코딩 함수 (cbor-js 라이브러리 사용)
        function decodeCBOR(binaryStr) {
            try {
                if (!binaryStr) {
                    return null;
                }
                
                // cbor-js 라이브러리 사용
                if (typeof window.CBOR === 'undefined' || !window.CBOR.decode) {
                    return "CBOR 라이브러리가 로드되지 않았습니다. 페이지를 새로고침해보세요.";
                }
                
                const bytes = binStringToUint8(binaryStr);
                
                // Uint8Array의 buffer 속성을 사용하여 ArrayBuffer 전달
                // slice()를 사용하여 새로운 ArrayBuffer 생성 (cbor-js 호환성을 위해)
                const arrayBuffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
                const decoded = window.CBOR.decode(arrayBuffer);
                
                // 디코딩 결과가 Uint8Array인 경우 (바이너리 데이터) 바이너리 문자열로 변환
                if (decoded instanceof Uint8Array) {
                    return uint8ToBinString(decoded);
                }
                
                // 일반 객체/배열/문자열인 경우 JSON으로 변환
                return JSON.stringify(decoded, null, 2);
                
            } catch (error) {
                return `CBOR 디코딩 오류: ${error.message}`;
            }
        }

        // CBOR 인코딩 함수 (cbor-js 라이브러리 사용)
        function encodeCBOR(data) {
            try {
                // cbor-js 라이브러리 사용
                if (typeof window.CBOR === 'undefined' || !window.CBOR.encode) {
                    throw new Error("CBOR 라이브러리가 로드되지 않았습니다.");
                }
                
                // 데이터 타입에 따른 처리
                let parsedData;
                if (typeof data === 'string') {
                    // 바이너리 문자열인지 확인 (이미지 등)
                    if (isBinaryString(data, 0.1)) {
                        // 바이너리 문자열을 Uint8Array로 변환
                        parsedData = binStringToUint8(data);
                    } else {
                        // 일반 텍스트 문자열 - JSON 파싱 시도
                        try {
                            parsedData = JSON.parse(data);
                        } catch (e) {
                            // JSON이 아닌 단순 문자열로 처리
                            parsedData = data;
                        }
                    }
                } else {
                    parsedData = data;
                }
                
                // cbor-js를 사용하여 인코딩
                const encoded = window.CBOR.encode(parsedData);
                
                // ArrayBuffer를 Uint8Array로 변환
                const uint8Array = new Uint8Array(encoded);
                
                return uint8Array;
                
            } catch (error) {
                console.error("CBOR 인코딩 오류:", error.message);
                throw new Error(`CBOR 인코딩 오류: ${error.message}`);
            }
        }

        // CBOR 데이터인지 확인하는 함수 (cbor-js 라이브러리 활용)
        function isCBORData(binaryStr) {
            if (!binaryStr || binaryStr.length === 0) {
                return false;
            }
            
            // cbor-js 라이브러리 확인
            if (typeof window.CBOR === 'undefined' || !window.CBOR.decode) {
                return false;
            }
            
            try {
                // 바이너리 문자열을 Uint8Array로 변환
                const uint8Bytes = binStringToUint8(binaryStr);

                // cbor-js로 디코딩 시도 - 성공하면 유효한 CBOR 데이터
                const arrayBuffer = uint8Bytes.buffer.slice(uint8Bytes.byteOffset, uint8Bytes.byteOffset + uint8Bytes.byteLength);
                const decoded = window.CBOR.decode(arrayBuffer);
                
                return true;
            } catch (e) {
                return false;
            }
        }
        
        // -------------------------
        // JSON/XML 구문 분석 및 포맷팅
        // -------------------------
        function formatXml(xml) {
            let formatted = '';
            const reg = /(>)(<)(\/*)/g;
            xml = xml.replace(reg, '$1\r\n$2$3');
            let pad = 0;
            xml.split('\r\n').forEach((node) => {
                let indent = 0;
                if (node.match(/.+<\/\w[^>]*>$/)) {
                    indent = 0;
                } else if (node.match(/^<\/\w/)) {
                    if (pad !== 0) pad -= 1;
                } else if (node.match(/^<\w([^>]*[^/])?>.*$/)) {
                    indent = 1;
                } else {
                    indent = 0;
                }
                formatted += '  '.repeat(pad) + node + '\r\n';
                pad += indent;
            });
            return formatted.trim();
        }
        function validateXml(xmlStr) {
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(xmlStr, "application/xml");
                const parsererror = doc.getElementsByTagName("parsererror");
                if (parsererror.length > 0) {
                    const msg = parsererror[0].textContent;
                    const match = msg.match(/at line (\d+)/i);
                    return {
                        valid: false,
                        error: msg,
                        errorLine: match ? parseInt(match[1], 10) : null
                    };
                }
                return { valid: true };
            } catch (e) {
                return { valid: false, error: e.message, errorLine: null };
            }
        }
        function syntaxHighlightJson(json) {
            if (typeof json != 'string') {
                json = JSON.stringify(json, undefined, 2);
            }
            json = json
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
                let cls = 'json-number';
                if (/^"/.test(match)) {
                    if (/:$/.test(match)) {
                        cls = 'json-key';
                    } else {
                        cls = 'json-string';
                    }
                } else if (/true|false/.test(match)) {
                    cls = 'json-boolean';
                } else if (/null/.test(match)) {
                    cls = 'json-null';
                }
                return '<span class="' + cls + '">' + match + '</span>';
            });
        }
        function syntaxHighlightXml(xml) {
            xml = xml
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            xml = xml.replace(/(&lt;\/?)([\w\-\.]+)(.*?)(\/?&gt;)/g, function (match, p1, p2, p3, p4) {
                return p1 + '<span class="xml-tag">' + p2 + '</span>' + p3 + p4;
            });
            xml = xml.replace(/([\w\-\.]+)="([^"]*)"/g, function (match, p1, p2) {
                return '<span class="xml-attr">' + p1 + '</span>="<span class="xml-attr-value">' + p2 + '</span>"';
            });
            return xml;
        }

        // -------------------------
        // Codec 전략 (객체지향 구조)
        // -------------------------
        const Codecs = (() => {
            // 바이너리 포맷 감지 함수
            function detectBinaryFormat(binaryStr) {
                if (!binaryStr || binaryStr.length < 4) return null;
                
                const bytes = Array.from(binaryStr).map(c => c.charCodeAt(0));
                
                // 이미지 포맷 감지
                if (bytes[0] === 0xFF && bytes[1] === 0xD8 && bytes[2] === 0xFF) {
                    return 'JPEG';
                }
                if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4E && bytes[3] === 0x47) {
                    return 'PNG';
                }
                if (bytes[0] === 0x47 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x38) {
                    return 'GIF';
                }
                if ((bytes[0] === 0x52 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x46) ||
                    (bytes[8] === 0x57 && bytes[9] === 0x45 && bytes[10] === 0x42 && bytes[11] === 0x50)) {
                    return 'WebP';
                }
                if (bytes[0] === 0x42 && bytes[1] === 0x4D) {
                    return 'BMP';
                }
                
                // 아카이브 포맷
                if (bytes[0] === 0x50 && bytes[1] === 0x4B && bytes[2] === 0x03 && bytes[3] === 0x04) {
                    return 'ZIP';
                }
                if (bytes[0] === 0x1F && bytes[1] === 0x8B) {
                    return 'GZIP';
                }
                if (bytes[0] === 0x75 && bytes[1] === 0x73 && bytes[2] === 0x74 && bytes[3] === 0x61) {
                    return 'TAR';
                }
                
                // PDF
                if (bytes[0] === 0x25 && bytes[1] === 0x50 && bytes[2] === 0x44 && bytes[3] === 0x46) {
                    return 'PDF';
                }
                
                // 실행 파일
                if (bytes[0] === 0x4D && bytes[1] === 0x5A) {
                    return 'EXE';
                }
                if (bytes[0] === 0x7F && bytes[1] === 0x45 && bytes[2] === 0x4C && bytes[3] === 0x46) {
                    return 'ELF';
                }
                
                // 기타 바이너리 포맷
                if (bytes[0] === 0x00 && bytes[1] === 0x00 && bytes[2] === 0x01 && bytes[3] === 0x00) {
                    return 'ICO';
                }
                
                return null;
            }

            // 공통 finalize
            function finalize(decoded, encoding, input, forceBinary = false) {
                const res = { decoded, encoding, error: null, isBinary: false, matched: true };
                res.isBinary = forceBinary || isBinaryString(res.decoded, 0.2);
                
                // 바이너리 데이터인 경우 포맷 감지 (CBOR는 제외)
                if (res.isBinary && !encoding.includes('CBOR')) {
                    const binaryFormat = detectBinaryFormat(res.decoded);
                    if (binaryFormat) {
                        res.encoding = `${encoding}-${binaryFormat}`;
                    }
                }
                
                // 디코딩 불가 케이스(텍스트성 인코딩으로 판단되었지만 의미 없는 결과)
                if (
                    input &&
                    res.isBinary &&
                    (encoding === 'Plain Text' || encoding === 'Quoted-Printable' || encoding === 'HTML Entities' || encoding === 'Unicode Escape')
                ) {
                    return { decoded: '', encoding: '', error: '디코딩할 수 없는 데이터입니다.', isBinary: false, matched: true };
                }
                return res;
            }

            // CBOR codec
            const CBOR = {
                id: 'cbor',
                label: 'CBOR',
                description: "CBOR(Concise Binary Object Representation)은 RFC 8949에서 정의된 바이너리 데이터 직렬화 포맷입니다. JSON보다 더 효율적이고 다양한 데이터 타입(정수, 부동소수점, 바이트 배열, 날짜 등)을 지원합니다. IoT, 웹API, 데이터 저장 등에서 JSON의 대안으로 사용됩니다.",
                detect(input) {
                    try {
                        // 전역 CBOR 라이브러리 명시적 참조
                        if (typeof window.CBOR === 'undefined' || !window.CBOR.decode) {
                            return { matched: false };
                        }
                        const s = input || '';
                        if (!s) {
                            return { matched: false };
                        }

                        // 1. 먼저 CBOR 구조적 특성 검사
                        if (isCBORData(s)) {
                            // CBOR 데이터로 확인된 경우 바로 디코딩 시도
                            const bytes = binStringToUint8(s);
                            const arrayBuffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
                            const value = window.CBOR.decode(arrayBuffer);

                            // 결과를 문자열로 변환
                            let out;
                            if (typeof value === 'string') {
                                out = value;
                            } else if (value instanceof Uint8Array) {
                                // 원시 바이트: 바이너리 문자열로 전달하여 HEX 뷰 제공
                                out = uint8ToBinString(value);
                            } else {
                                try {
                                    out = JSON.stringify(value);
                                } catch {
                                    out = String(value);
                                }
                            }
                            return finalize(out, this.label, input, false); // forceBinary = false (텍스트 결과이므로)
                        }

                        // 2. Base64 형태로 인코딩된 CBOR 데이터 검사
                        const looksBase64 = /^[A-Za-z0-9+/=\s]+$/.test(s) && s.replace(/\s/g, '').length % 4 === 0 && s.replace(/\s/g, '').length >= 8;
                        const looksBinary = isBinaryString(s, 0.05);

                        if (!looksBase64 && !looksBinary) return { matched: false };

                        // 바이트 준비
                        let bytes;
                        if (looksBase64) {
                            try {
                                bytes = base64ToUint8(s);
                            } catch {
                                return { matched: false };
                            }
                        } else {
                            bytes = binStringToUint8(s);
                        }

                        // 디코드 시도 - ArrayBuffer로 변환
                        const arrayBuffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
                        const value = window.CBOR.decode(arrayBuffer);

                        // 결과를 문자열로 변환
                        let out;
                        if (typeof value === 'string') {
                            out = value;
                        } else if (value instanceof Uint8Array) {
                            // 원시 바이트: 바이너리 문자열로 전달하여 HEX 뷰 제공
                            out = uint8ToBinString(value);
                        } else {
                            try {
                                out = JSON.stringify(value);
                            } catch {
                                out = String(value);
                            }
                        }
                        return finalize(out, this.label, input);
                    } catch {
                        return { matched: false };
                    }
                },
                encode(input) {
                    // 자체 CBOR 인코딩 함수 사용
                    try {
                        let data;
                        // JSON 문자열인지 확인하고 파싱 시도
                        try {
                            data = JSON.parse(input);
                        } catch {
                            // JSON이 아니면 문자열로 처리
                            data = input;
                        }
                        
                        const bytes = encodeCBOR(data);
                        
                        // Binary 형태로 반환
                        return Array.from(bytes).map(b => String.fromCharCode(b)).join('');
                    } catch (e) {
                        return '';
                    }
                }
            };

            const Hex = {
                id: 'hex',
                label: 'Hex (Base16)',
                description: "Hex(16진수/Base16) 인코딩은 각 바이트(8비트)를 두 자리 16진수 문자(0-9, A-F)로 표현하는 방식입니다. 바이너리 데이터를 텍스트로 안전하게 전송하거나 저장할 때 사용되며, 색상 코드(#FF0000), MAC 주소, 암호화 해시값 등에서 흔히 볼 수 있습니다. 예: 'A' → 41, 'ABC' → 414243",
                detect(input) {
                    try {
                        const compact = (input || '').replace(/\s/g, '');
                        
                        // h'값' 형식 또는 기본 hex 형식 지원
                        let hex = '';
                        if (/^h'([0-9a-fA-F]+)'$/.test(compact)) {
                            // h'값' 형식에서 hex 값 추출
                            hex = compact.match(/^h'([0-9a-fA-F]+)'$/)[1];
                        } else if (/^(0x)?([0-9a-fA-F]{2})+$/.test(compact)) {
                            // 기본 hex 형식
                            hex = compact.replace(/^0x/, '');
                        } else {
                            return { matched: false };
                        }
                        
                        // hex 길이가 짝수인지 확인
                        if (hex.length % 2 !== 0) {
                            return { matched: false };
                        }
                        
                        // 바이트 배열로 변환
                        const bytes = new Uint8Array(hex.length / 2);
                        for (let i = 0; i < hex.length; i += 2) {
                            bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
                        }
                        
                        // 바이너리 문자열로 변환
                        let binaryStr = '';
                        for (let i = 0; i < bytes.length; i++) {
                            binaryStr += String.fromCharCode(bytes[i]);
                        }
                        
                        // 항상 바이너리 데이터로 처리
                        return finalize(binaryStr, this.label, input, true); // isBinary = true
                    } catch (error) {
                        return { matched: false };
                    }
                },
                encode(input) {
                    // 바이너리 데이터를 직접 Hex 인코딩 (UTF-8 변환 안함)
                    try {
                        // 입력이 바이너리 문자열인 경우 각 문자의 코드를 직접 hex로 변환
                        return Array.from(input).map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join('').toUpperCase();
                    } catch (error) {
                        return '';
                    }
                }
            };

            const Base64 = {
                id: 'base64',
                label: 'Base64',
                description: "Base64는 8비트 바이너리 데이터를 64개의 안전한 ASCII 문자(A-Z, a-z, 0-9, +, /)로 인코딩하는 방식입니다. 이메일 첨부파일, 웹의 데이터 URL(data:image/png;base64,...), JSON Web Token, API 통신 등에서 광범위하게 사용됩니다. 3바이트를 4문자로 변환하므로 약 33% 크기가 증가합니다.",
                detect(input) {
                    try {
                        if (
                            /^[A-Za-z0-9+/=\s]+$/.test(input || '') &&
                            (input || '').length >= 8 &&
                            (input || '').replace(/\s/g, '').length % 4 === 0
                        ) {
                            const base64Clean = (input || '').replace(/\s/g, '');
                            // Base64를 바이트 배열로 디코딩
                            const binaryString = atob(base64Clean);
                            const bytes = new Uint8Array(binaryString.length);
                            for (let i = 0; i < binaryString.length; i++) {
                                bytes[i] = binaryString.charCodeAt(i);
                            }
                            // UTF-8로 디코딩 시도
                            try {
                                const str = new TextDecoder('utf-8').decode(bytes);
                                return finalize(str, this.label, input);
                            } catch {
                                // UTF-8 디코딩 실패시 바이너리 문자열로 처리
                                return finalize(binaryString, this.label, input);
                            }
                        }
                    } catch {}
                    return { matched: false };
                },
                encode(input) {
                    try {
                        // UTF-8 바이트로 변환 후 Base64 인코딩
                        const utf8Bytes = new TextEncoder().encode(input);
                        const binaryString = Array.from(utf8Bytes).map(b => String.fromCharCode(b)).join('');
                        return btoa(binaryString);
                    } catch {
                        // Fallback
                        return btoa(unescape(encodeURIComponent(input)));
                    }
                }
            };

            const Base64URL = {
                id: 'base64url',
                label: 'Base64URL',
                description: "Base64URL은 Base64의 URL-safe 변형으로, URL과 파일명에서 문제가 되는 문자들을 대체합니다. '+'를 '-'로, '/'를 '_'로 바꾸고 패딩('=')을 제거합니다. JWT(JSON Web Token), OAuth 토큰, URL 매개변수에서 바이너리 데이터를 안전하게 전달할 때 사용됩니다.",
                detect(input) {
                    try {
                        const s = input || '';
                        if (/^[A-Za-z0-9_\-=]+$/.test(s) && s.length >= 8 && (s.includes('-') || s.includes('_'))) {
                            let b64 = s.replace(/-/g, '+').replace(/_/g, '/');
                            while (b64.length % 4 !== 0) b64 += '=';
                            const out = atob(b64);
                            return finalize(out, this.label, input);
                        }
                    } catch {}
                    return { matched: false };
                },
                encode(input) {
                    try {
                        let b64 = btoa(input);
                        return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
                    } catch {
                        let b64 = btoa(unescape(encodeURIComponent(input)));
                        return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
                    }
                }
            };

            const UrlEncoding = {
                id: 'url',
                label: 'URL Encoding',
                description: "URL Encoding(퍼센트 인코딩)은 URL에서 특별한 의미를 가지거나 안전하지 않은 문자들을 %XX 형태로 변환하는 방식입니다. 공백은 %20, 한글은 UTF-8로 변환 후 각 바이트를 %XX로 표현합니다. 웹 폼 데이터 전송, 쿼리 스트링, REST API에서 필수적으로 사용됩니다. 예: '안녕' → %EC%95%88%EB%85%95",
                detect(input) {
                    try {
                        const s = input || '';
                        if (/%[0-9A-Fa-f]{2}/.test(s)) {
                            const out = decodeURIComponent(s);
                            return finalize(out, this.label, input);
                        }
                    } catch {}
                    return { matched: false };
                },
                encode(input) {
                    return encodeURIComponent(input);
                }
            };

            const HtmlEntities = {
                id: 'html',
                label: 'HTML Entities',
                description: "HTML Entities는 HTML에서 특별한 의미를 가지는 문자들을 안전하게 표현하기 위한 방식입니다. &lt;(&<), &gt;(>), &amp;(&), &quot;(\"), &#숫자; 형태로 인코딩됩니다. 웹 개발에서 XSS 공격 방지, XML/HTML 문서에서 특수문자 표시, 이메일 HTML 템플릿 등에 사용됩니다.",
                detect(input) {
                    try {
                        const s = input || '';
                        if (/&[a-zA-Z]+;/.test(s)) {
                            const txt = document.createElement('textarea');
                            txt.innerHTML = s;
                            return finalize(txt.value, this.label, input);
                        }
                    } catch {}
                    return { matched: false };
                },
                encode(input) {
                    return input.replace(/[\u00A0-\u9999<>&"']/gim, i => '&#' + i.charCodeAt(0) + ';');
                }
            };

            const UnicodeEsc = {
                id: 'unicode',
                label: 'Unicode Escape (\\uXXXX)',
                description: "Unicode Escape는 유니코드 문자를 \\uXXXX 형태의 4자리 16진수로 표현하는 방식입니다. JavaScript, JSON, Java, C# 등의 프로그래밍 언어에서 비ASCII 문자를 안전하게 표현할 때 사용됩니다. 예: '가' → \\uAC00, '☃' → \\u2603. 국제화(i18n) 파일이나 로그 분석에서 자주 마주치게 됩니다.",
                detect(input) {
                    try {
                        const s = input || '';
                        if (/\\u[0-9a-fA-F]{4}/.test(s)) {
                            const out = s.replace(/\\u([0-9a-fA-F]{4})/g, (m, g1) => String.fromCharCode(parseInt(g1, 16)));
                            return finalize(out, this.label, input);
                        }
                    } catch {}
                    return { matched: false };
                },
                encode(input) {
                    return input.replace(/[\s\S]/g, c => '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4));
                }
            };

            const UTF8Bytes = {
                id: 'utf8',
                label: 'UTF-8',
                description: "UTF-8은 유니코드 문자를 1~4바이트의 가변 길이로 인코딩하는 방식입니다. ASCII와 완전히 호환되며(ASCII 문자는 1바이트), 전 세계 모든 언어를 표현할 수 있어 웹의 표준 인코딩입니다. 한글은 보통 3바이트로 인코딩됩니다. 예: 'A' → 0x41(1바이트), '가' → 0xEA 0xB0 0x80(3바이트)",
                detect(input) {
                    try {
                        const s = input || '';
                        // 바이너리 문자열을 UTF-8으로 디코딩 시도
                        if (s.length > 0 && isBinaryString(s, 0.05)) {
                            try {
                                const bytes = binStringToUint8(s);
                                const str = new TextDecoder('utf-8', { fatal: true }).decode(bytes);
                                return finalize(str, this.label, input);
                            } catch {
                                return { matched: false };
                            }
                        }
                    } catch {}
                    return { matched: false };
                },
                encode(input) {
                    try {
                        const utf8Bytes = new TextEncoder().encode(input);
                        return Array.from(utf8Bytes).map(b => String.fromCharCode(b)).join('');
                    } catch {
                        return '';
                    }
                }
            };

            const ASCII = {
                id: 'ascii',
                label: 'ASCII',
                description: "ASCII(American Standard Code for Information Interchange)는 7비트(0-127)로 영문 알파벳, 숫자, 기본 특수문자를 표현하는 가장 기본적인 문자 인코딩입니다. 1963년에 제정되어 모든 현대 인코딩의 기초가 되었으며, UTF-8과도 완전 호환됩니다. 레거시 시스템이나 제한된 환경에서 여전히 사용됩니다.",
                detect(input) {
                    try {
                        const s = input || '';
                        // 바이너리 문자열을 ASCII로 디코딩 시도
                        if (s.length > 0 && isBinaryString(s, 0.05)) {
                            let validAscii = true;
                            let result = '';
                            for (let i = 0; i < s.length; i++) {
                                const code = s.charCodeAt(i);
                                if (code > 127) {
                                    validAscii = false;
                                    break;
                                }
                                result += String.fromCharCode(code);
                            }
                            if (validAscii) {
                                return finalize(result, this.label, input);
                            }
                        }
                    } catch {}
                    return { matched: false };
                },
                encode(input) {
                    try {
                        let result = '';
                        for (let i = 0; i < input.length; i++) {
                            const code = input.charCodeAt(i);
                            if (code > 127) {
                                throw new Error('Non-ASCII character detected');
                            }
                            result += String.fromCharCode(code);
                        }
                        return result;
                    } catch {
                        return '';
                    }
                }
            };

            const Base32 = {
                id: 'base32',
                label: 'Base32',
                description: "Base32는 5비트씩 묶어 32개의 문자(A-Z, 2-7)로 인코딩하는 방식입니다. Base64보다 적은 문자를 사용하여 대소문자를 구분하지 않아도 되고, 혼동하기 쉬운 문자(0, 1, 8, 9)를 제외하여 더 안전합니다. TOTP 인증 시크릿 키, Git 커밋 해시, 분산 시스템의 ID 등에 사용됩니다. 8바이트가 5문자로 변환되어 약 60% 크기 증가합니다.",
                detect(input) {
                    try {
                        const s = (input || '').toUpperCase().replace(/\s/g, '');
                        if (/^[A-Z2-7=]+$/.test(s) && s.length >= 8 && s.length % 8 === 0) {
                            const decoded = this.base32Decode(s);
                            if (decoded !== null) {
                                // UTF-8로 디코딩 시도
                                try {
                                    const bytes = binStringToUint8(decoded);
                                    const str = new TextDecoder('utf-8').decode(bytes);
                                    return finalize(str, this.label, input);
                                } catch {
                                    // UTF-8 디코딩 실패시 바이너리 문자열로 처리
                                    return finalize(decoded, this.label, input);
                                }
                            }
                        }
                    } catch {}
                    return { matched: false };
                },
                encode(input) {
                    try {
                        const utf8Bytes = new TextEncoder().encode(input);
                        const binaryString = Array.from(utf8Bytes).map(b => String.fromCharCode(b)).join('');
                        return this.base32Encode(binaryString);
                    } catch {
                        return '';
                    }
                },
                base32Encode(binaryStr) {
                    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
                    let bits = '';
                    
                    // 바이너리 문자열을 비트로 변환
                    for (let i = 0; i < binaryStr.length; i++) {
                        const byte = binaryStr.charCodeAt(i);
                        bits += byte.toString(2).padStart(8, '0');
                    }
                    
                    // 5비트씩 묶어서 base32 문자로 변환
                    let result = '';
                    for (let i = 0; i < bits.length; i += 5) {
                        const chunk = bits.slice(i, i + 5);
                        if (chunk.length === 5) {
                            result += alphabet[parseInt(chunk, 2)];
                        } else if (chunk.length > 0) {
                            // 패딩이 필요한 경우
                            const paddedChunk = chunk.padEnd(5, '0');
                            result += alphabet[parseInt(paddedChunk, 2)];
                        }
                    }
                    
                    // 패딩 추가
                    while (result.length % 8 !== 0) {
                        result += '=';
                    }
                    
                    return result;
                },
                base32Decode(base32Str) {
                    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
                    const str = base32Str.replace(/=/g, '');
                    let bits = '';
                    
                    // base32 문자를 비트로 변환
                    for (let i = 0; i < str.length; i++) {
                        const char = str[i];
                        const index = alphabet.indexOf(char);
                        if (index === -1) return null;
                        bits += index.toString(2).padStart(5, '0');
                    }
                    
                    // 8비트씩 묶어서 바이트로 변환
                    let result = '';
                    for (let i = 0; i < bits.length; i += 8) {
                        const chunk = bits.slice(i, i + 8);
                        if (chunk.length === 8) {
                            result += String.fromCharCode(parseInt(chunk, 2));
                        }
                    }
                    
                    return result;
                }
            };

            const QuotedPrintable = {
                id: 'qp',
                label: 'Quoted-Printable',
                description: "Quoted-Printable은 8비트 데이터를 7비트 ASCII 환경에서 안전하게 전송하기 위한 MIME 인코딩 방식입니다. 일반 ASCII 문자는 그대로 두고, 특수문자나 비ASCII 문자만 =XX 형태로 인코딩합니다. 이메일에서 한글이나 특수문자가 포함된 텍스트를 전송할 때 사용되며, Base64보다 가독성이 좋습니다.",
                detect(input) {
                    try {
                        const s = input || '';
                        const matches = s.match(/=([0-9A-Fa-f]{2})/g);
                        if (matches && matches.length > 0 && matches.length * 3 > s.length * 0.3) {
                            let out = s.replace(/=(\r?\n|\r)/g, '').replace(/=([0-9A-Fa-f]{2})/g, (m, g1) =>
                                String.fromCharCode(parseInt(g1, 16))
                            );
                            return finalize(out, this.label, input);
                        }
                    } catch {}
                    return { matched: false };
                },
                encode(input) {
                    return input.replace(/[\x00-\x1F\x7F-\xFF=]/g, c => '=' + c.charCodeAt(0).toString(16).toUpperCase().padStart(2, '0'));
                }
            };

            const Binary = {
                id: 'bin',
                label: 'Binary',
                description: 'Binary data (including non-visible control characters).',
                detect(input) {
                    const s = input || '';
                    // 민감도 높임: 5%
                    if (isBinaryString(s, 0.05)) {
                        return { decoded: s, encoding: this.label, error: null, isBinary: true, matched: true };
                    }
                    return { matched: false };
                }
                // encode 없음 (노출 X)
            };

            const registry = [
                // CBOR을 먼저 시도해 Base64로 포장된 CBOR까지 처리
                CBOR,
                Hex,
                Base64,
                Base64URL,
                Base32,
                UTF8Bytes,
                ASCII,
                Binary,
                UrlEncoding,
                HtmlEntities,
                UnicodeEsc,
                QuotedPrintable
            ];

            function detect(input) {
                for (const codec of registry) {
                    const r = codec.detect && codec.detect(input);
                    if (r && r.matched) return r;
                }
                
                // Plain Text fallback 전에 CBOR 가능성 체크
                if (input && input.length > 0) {
                    if (isCBORData(input)) {
                        // CBOR로 인식된 경우 바이너리로 처리
                        return finalize(input, 'CBOR', input, true); // isBinary = true
                    }
                }
                
                // Fallback
                return finalize(input, 'Plain Text', input);
            }

            function getEncoderLabels() {
                return registry.filter(c => typeof c.encode === 'function').map(c => c.label);
            }
            function getEncoderByLabel(label) {
                return registry.find(c => c.label === label && typeof c.encode === 'function');
            }
            function getDescriptionByLabel(label) {
                const c = registry.find(c => c.label === label);
                return (c && c.description) || '';
            }

            return { detect, getEncoderLabels, getEncoderByLabel, getDescriptionByLabel };
        })();
        // -------------------------

            // 인코딩/디코딩 함수 통합
            const detectAndDecode = (input) => Codecs.detect(input);
            const encodeText = (input, encodingLabel) => {
                const encoder = Codecs.getEncoderByLabel(encodingLabel) || Codecs.getEncoderByLabel('Base64');
                try {
                    return encoder ? encoder.encode(input) : input;
                } catch {
                    return '';
                }
            };

        function renderBeautifiedWithError(beautified, syntaxType, syntaxErrorLine) {
            if (!beautified) return null;
            const lines = beautified.split('\n');
            return (
                React.createElement('pre', {
                    style: {
                        background: '#23272e',
                        color: '#fff',
                        borderRadius: 6,
                        padding: 16,
                        fontSize: 15,
                        overflowX: 'auto',
                        marginBottom: 0,
                        marginTop: 0
                    }
                },
                    lines.map((line, idx) => {
                        let style = {};
                        if (syntaxErrorLine && idx + 1 === syntaxErrorLine) {
                            style = { background: '#ffebee', color: '#c62828' };
                        }
                        let html = line;
                        if (syntaxType === 'json') {
                            html = syntaxHighlightJson(line);
                        } else if (syntaxType === 'xml') {
                            html = syntaxHighlightXml(line);
                        }
                        return React.createElement('div', {
                            key: idx,
                            style: { ...style, whiteSpace: 'pre' },
                            dangerouslySetInnerHTML: { __html: html }
                        });
                    })
                )
            );
        }

        // -------------------------
        // 다국어 지원 시스템
        // -------------------------
        
        // 언어 감지 및 기본 언어 설정 (localStorage 우선)
        function detectBrowserLanguage() {
            // localStorage에서 저장된 언어 설정 확인
            const savedLanguage = localStorage.getItem('decodeall-language');
            const supportedLanguages = ['ko', 'en', 'ja', 'zh-CN', 'zh-TW', 'es', 'fr', 'de', 'ru', 'pt', 'it'];
            if (savedLanguage && supportedLanguages.includes(savedLanguage)) {
                return savedLanguage;
            }
            
            // 저장된 설정이 없으면 브라우저 언어 감지
            const lang = navigator.language || navigator.userLanguage;
            if (lang.startsWith('ko')) return 'ko';
            if (lang.startsWith('ja')) return 'ja';
            if (lang === 'zh-CN' || lang === 'zh-Hans') return 'zh-CN';
            if (lang === 'zh-TW' || lang === 'zh-Hant') return 'zh-TW';
            if (lang.startsWith('es')) return 'es';
            if (lang.startsWith('fr')) return 'fr';
            if (lang.startsWith('de')) return 'de';
            if (lang.startsWith('ru')) return 'ru';
            if (lang.startsWith('pt')) return 'pt';
            if (lang.startsWith('it')) return 'it';
            return 'en'; // 기본값은 영어
        }

        // i18next 초기화
        i18next.init({
            lng: detectBrowserLanguage(),
            fallbackLng: 'en',
            debug: false,
            resources: {
                ko: { translation: {} },
                en: { translation: {} },
                ja: { translation: {} },
                'zh-CN': { translation: {} },
                'zh-TW': { translation: {} },
                es: { translation: {} },
                fr: { translation: {} },
                de: { translation: {} },
                ru: { translation: {} },
                pt: { translation: {} },
                it: { translation: {} }
            }
        });

        // 언어 파일 로드 함수
        async function loadLanguageResources() {
            try {
                const languages = [
                    { code: 'ko', file: './locales/ko.json' },
                    { code: 'en', file: './locales/en.json' },
                    { code: 'ja', file: './locales/ja.json' },
                    { code: 'zh-CN', file: './locales/zh-CN.json' },
                    { code: 'zh-TW', file: './locales/zh-TW.json' },
                    { code: 'es', file: './locales/es.json' },
                    { code: 'fr', file: './locales/fr.json' },
                    { code: 'de', file: './locales/de.json' },
                    { code: 'ru', file: './locales/ru.json' },
                    { code: 'pt', file: './locales/pt.json' },
                    { code: 'it', file: './locales/it.json' }
                ];
                
                for (const lang of languages) {
                    const response = await fetch(lang.file);
                    const data = await response.json();
                    i18next.addResourceBundle(lang.code, 'translation', data, true, true);
                }
                
                return true;
            } catch (error) {
                console.error('Failed to load language resources:', error);
                return false;
            }
        }

        // React hooks 선언
        const { useState, useEffect, useRef } = React;

        function EncoderDecoderTabs() {
            // 언어 상태
            const [language, setLanguage] = useState(detectBrowserLanguage());
            const [isLanguageLoaded, setIsLanguageLoaded] = useState(false);
            
            // i18next 훅 사용
            const { t, i18n } = ReactI18next.useTranslation();
            
            // 번역 함수들
            const getDragMessage = () => t('common.dragMessage');
            
            // 언어 리소스 로드
            useEffect(() => {
                loadLanguageResources().then((success) => {
                    if (success) {
                        i18n.changeLanguage(language).then(() => {
                            // 초기 로드 시 페이지 제목과 메타 태그 업데이트
                            document.title = i18n.t('title');
                            
                            // 메타 태그 업데이트
                            const descriptionMeta = document.querySelector('meta[name="description"]');
                            if (descriptionMeta) {
                                descriptionMeta.content = i18n.t('meta.description');
                            }
                            
                            const keywordsMeta = document.querySelector('meta[name="keywords"]');
                            if (keywordsMeta) {
                                keywordsMeta.content = i18n.t('meta.keywords');
                            }
                            
                            // Open Graph 메타 태그 업데이트
                            const ogTitle = document.querySelector('meta[property="og:title"]');
                            if (ogTitle) {
                                ogTitle.content = i18n.t('title');
                            }
                            
                            const ogDescription = document.querySelector('meta[property="og:description"]');
                            if (ogDescription) {
                                ogDescription.content = i18n.t('meta.description');
                            }
                            
                            // Twitter 메타 태그 업데이트
                            const twitterTitle = document.querySelector('meta[property="twitter:title"]');
                            if (twitterTitle) {
                                twitterTitle.content = i18n.t('title');
                            }
                            
                            const twitterDescription = document.querySelector('meta[property="twitter:description"]');
                            if (twitterDescription) {
                                twitterDescription.content = i18n.t('meta.description');
                            }
                        });
                        setIsLanguageLoaded(true);
                    }
                });
            }, []);

            // 언어 변경 처리
            useEffect(() => {
                if (isLanguageLoaded) {
                    i18n.changeLanguage(language).then(() => {
                        // 언어 변경이 완료된 후 페이지 제목과 메타 태그 업데이트
                        document.title = i18n.t('title');
                        
                        // 메타 태그 업데이트
                        const descriptionMeta = document.querySelector('meta[name="description"]');
                        if (descriptionMeta) {
                            descriptionMeta.content = i18n.t('meta.description');
                        }
                        
                        const keywordsMeta = document.querySelector('meta[name="keywords"]');
                        if (keywordsMeta) {
                            keywordsMeta.content = i18n.t('meta.keywords');
                        }
                        
                        // Open Graph 메타 태그 업데이트
                        const ogTitle = document.querySelector('meta[property="og:title"]');
                        if (ogTitle) {
                            ogTitle.content = i18n.t('title');
                        }
                        
                        const ogDescription = document.querySelector('meta[property="og:description"]');
                        if (ogDescription) {
                            ogDescription.content = i18n.t('meta.description');
                        }
                        
                        // Twitter 메타 태그 업데이트
                        const twitterTitle = document.querySelector('meta[property="twitter:title"]');
                        if (twitterTitle) {
                            twitterTitle.content = i18n.t('title');
                        }
                        
                        const twitterDescription = document.querySelector('meta[property="twitter:description"]');
                        if (twitterDescription) {
                            twitterDescription.content = i18n.t('meta.description');
                        }
                    });
                    localStorage.setItem('decodeall-language', language);
                }
            }, [language, isLanguageLoaded]);
            
            const [tab, setTab] = useState(0);

            // 드래그오버 상태 추가
            const [isDragOverInput, setIsDragOverInput] = useState(false);
            const [isDragOverEncode, setIsDragOverEncode] = useState(false);

            // 디코딩 상태
            const [input, setInput] = useState('');
            const [output, setOutput] = useState('');
            const [encoding, setEncoding] = useState('');
            const [error, setError] = useState(null);
            
            // 데이터 포맷 상태
            const [dataFormat, setDataFormat] = useState(null); // 'text', 'json', 'xml', 'binary'
            const [binaryFormat, setBinaryFormat] = useState(null); // 'image', 'cbor', 'unknown'
            const [imageInfo, setImageInfo] = useState(null); // { src, mime, ext }
            const [cborDiagnostic, setCborDiagnostic] = useState(''); // CBOR 진단 표기 결과

            // 뷰티파이/구문 강조 상태
            const [beautified, setBeautified] = useState('');
            const [syntaxError, setSyntaxError] = useState(null);
            const [syntaxErrorLine, setSyntaxErrorLine] = useState(null);

            // 인코딩 상태
            const [encodeInput, setEncodeInput] = useState('');
            const [encodeType, setEncodeType] = useState('Base64');
            const [encodeResult, setEncodeResult] = useState('');
            const [encodeHexResult, setEncodeHexResult] = useState('');

            const inputRef = useRef(null);
            const outputRef = useRef(null);
            const encodeInputRef = useRef(null);
            const paperRef = useRef(null);

            // Snackbar(토스트) 상태
            const [toast, setToast] = useState({ open: false, message: '', severity: 'success' });
            const showToast = (message, severity = 'success') => setToast({ open: true, message, severity });
            const handleToastClose = (event, reason) => {
                if (reason === 'clickaway') return;
                setToast(prev => ({ ...prev, open: false }));
            };

            useEffect(() => {
                gsap.from(paperRef.current, {
                    y: 60,
                    opacity: 0,
                    duration: 1,
                    ease: "power3.out"
                });
            }, []);

            // 언어 변경 시 HTML lang 속성 업데이트 및 localStorage 저장
            useEffect(() => {
                document.documentElement.lang = language;
                // 언어 설정을 localStorage에 저장
                localStorage.setItem('decodeall-language', language);
            }, [language]);

            // -------------------------
            // 공통 이벤트 핸들러
            // -------------------------
            
            // 복사 기능 통합
            const handleCopy = async (content, isBinary = false) => {
                if (!content) return;
                
                if (isBinary) {
                    showToast(t('messages.binaryNotCopyable'), 'error');
                    return;
                }
                
                try {
                    await navigator.clipboard.writeText(content);
                    showToast(t('messages.copySuccess'), 'success');
                } catch {
                    showToast(t('messages.copyError'), 'error');
                }
            };
            
            // 다운로드 기능 통합
            const handleDownload = (content, filename, isBinary = false) => {
                if (!content) return;
                
                try {
                    let success;
                    if (isBinary) {
                        success = downloadBinaryFile(content, filename);
                    } else {
                        success = downloadTextFile(content, filename);
                    }
                    
                    if (success) {
                        showToast(t('messages.downloadSuccess'), 'success');
                    } else {
                        showToast(t('messages.downloadError'), 'error');
                    }
                } catch (error) {
                    showToast(t('messages.downloadError'), 'error');
                }
            };

            // 1. 인코딩 감지 및 디코딩 함수
            const detectEncoding = (text) => {
                return Codecs.detect(text);
            };

            // 2. 디코딩된 데이터의 포맷 판별 함수 (비동기)
            const findDataFormat = async (decodedData) => {
                if (!decodedData) return null;
                
                // 바이트 배열 생성
                const bytes = Array.from(decodedData).map(c => c.charCodeAt(0));
                
                // 1. 우선 CBOR 검사 (바이너리 판별 전에)
                if (bytes.length >= 1) {
                    if (isCBORData(decodedData)) {
                        return 'binary';
                    }
                }
                
                // 2. 이미지 포맷 검사
                if (bytes.length >= 2) {
                    const imageResult = await sniffImage(decodedData);
                    if (imageResult) {
                        return 'binary';
                    }
                }
                
                // 3. 기타 알려진 바이너리 시그니처 검사
                if (bytes.length >= 4) {
                    if ((bytes[0] === 0xFF && bytes[1] === 0xD8) || // JPEG
                        (bytes[0] === 0x89 && bytes[1] === 0x50) || // PNG
                        (bytes[0] === 0x47 && bytes[1] === 0x49) || // GIF
                        (bytes[0] === 0x42 && bytes[1] === 0x4D) || // BMP
                        (bytes[0] === 0x50 && bytes[1] === 0x4B) || // ZIP
                        (bytes[0] === 0x1F && bytes[1] === 0x8B) || // GZIP
                        (bytes[0] === 0x25 && bytes[1] === 0x50) || // PDF
                        (bytes[0] === 0x4D && bytes[1] === 0x5A) || // EXE
                        (bytes[0] === 0x7F && bytes[1] === 0x45)) { // ELF
                        return 'binary';
                    }
                }
                
                // 4. 바이너리 특성 체크 (통계적 접근)
                let controlChars = 0;
                let highBytes = 0;
                let nullBytes = 0;
                
                for (let i = 0; i < decodedData.length; i++) {
                    const code = decodedData.charCodeAt(i);
                    // 제어 문자 (탭, 개행, 캐리지 리턴 제외)
                    if ((code < 0x09 || (code > 0x0D && code < 0x20) || code === 0x7F)) {
                        controlChars++;
                    }
                    // 높은 바이트 값 (128 이상)
                    if (code >= 128) {
                        highBytes++;
                    }
                    // null 바이트
                    if (code === 0) {
                        nullBytes++;
                    }
                }
                
                const controlRatio = controlChars / decodedData.length;
                const highByteRatio = highBytes / decodedData.length;
                const nullRatio = nullBytes / decodedData.length;
                
                // 바이너리 판별 조건 (null 바이트가 있거나 제어문자 비율이 높으면 바이너리)
                if (nullRatio > 0 || controlRatio > 0.02 || highByteRatio > 0.3) {
                    return 'binary';
                }
                
                // 5. JSON 파싱 시도
                try {
                    JSON.parse(decodedData);
                    return 'json';
                } catch {}
                
                // 6. XML 체크
                if (/<[\w\s="'\/\-\.:]+>/.test(decodedData)) {
                    const xmlCheck = validateXml(decodedData);
                    if (xmlCheck.valid) {
                        return 'xml';
                    }
                }
                
                return 'text';
            };

            // 3. 바이너리 데이터의 세부 포맷 판별 함수 (비동기)
            const findBinaryFormat = async (binaryData) => {
                // 이미지 포맷 체크
                const imageResult = await sniffImage(binaryData);
                if (imageResult) {
                    return { type: 'image', info: imageResult };
                }
                
                // CBOR 포맷 체크
                if (isCBORData(binaryData)) {
                    // CBOR 디코딩 시도하여 추가 정보 제공
                    try {
                        // cbor-js 라이브러리 확인
                        if (typeof CBOR !== 'undefined' && CBOR.decode) {
                            const bytes = binStringToUint8(binaryData);
                            // ArrayBuffer로 변환
                            const arrayBuffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
                            const decoded = CBOR.decode(arrayBuffer);
                            return { 
                                type: 'cbor', 
                                decoded: decoded,
                                summary: typeof decoded === 'object' ? 
                                    (Array.isArray(decoded) ? `Array[${decoded.length}]` : `Object{${Object.keys(decoded).length}}`) :
                                    typeof decoded
                            };
                        } else {
                            return { type: 'cbor' };
                        }
                    } catch (e) {
                        return { type: 'cbor', error: e.message };
                    }
                }
                
                return { type: 'unknown' };
            };

            // CBOR 데이터를 Diagnostic Notation으로 변환하는 함수
            const toCborDiagnostic = (cborBytes) => {
                try {
                    // cbor-js 라이브러리 확인
                    if (typeof window.CBOR === 'undefined' || !window.CBOR.decode) {
                        return "CBOR 라이브러리를 찾을 수 없습니다. 페이지를 새로고침해보세요.";
                    }
                    
                    // CBOR 디코딩 - Uint8Array를 ArrayBuffer로 변환
                    const arrayBuffer = cborBytes.buffer.slice(cborBytes.byteOffset, cborBytes.byteOffset + cborBytes.byteLength);
                    const decoded = window.CBOR.decode(arrayBuffer);
                    
                    // 진단 표기법으로 포맷팅
                    function format(value, depth = 0) {
                        const indent = '  '.repeat(depth);
                        
                        if (typeof value === 'string') return `"${value}"`;
                        if (typeof value === 'number') return value.toString();
                        if (typeof value === 'boolean') return value.toString();
                        if (value === null) return 'null';
                        if (value === undefined) return 'undefined';
                        
                        if (value instanceof Uint8Array) {
                            const hex = Array.from(value).map(b => b.toString(16).padStart(2, '0')).join('');
                            return `h'${hex}'`;
                        }
                        
                        if (Array.isArray(value)) {
                            if (value.length === 0) return '[]';
                            if (depth > 3) return '[...]'; // 깊이 제한
                            const items = value.map(item => format(item, depth + 1));
                            if (items.join(', ').length < 80) {
                                return `[${items.join(', ')}]`;
                            } else {
                                return `[\n${indent}  ${items.join(',\n' + indent + '  ')}\n${indent}]`;
                            }
                        }
                        
                        if (value instanceof Map) {
                            if (value.size === 0) return '{}';
                            if (depth > 3) return '{...}'; // 깊이 제한
                            const entries = Array.from(value.entries()).map(([k, v]) => 
                                `${format(k, depth + 1)}: ${format(v, depth + 1)}`
                            );
                            if (entries.join(', ').length < 80) {
                                return `{${entries.join(', ')}}`;
                            } else {
                                return `{\n${indent}  ${entries.join(',\n' + indent + '  ')}\n${indent}}`;
                            }
                        }
                        
                        if (typeof value === 'object' && value !== null) {
                            const entries = Object.entries(value);
                            if (entries.length === 0) return '{}';
                            if (depth > 3) return '{...}'; // 깊이 제한
                            const formatted = entries.map(([k, v]) => 
                                `"${k}": ${format(v, depth + 1)}`
                            );
                            if (formatted.join(', ').length < 80) {
                                return `{${formatted.join(', ')}}`;
                            } else {
                                return `{\n${indent}  ${formatted.join(',\n' + indent + '  ')}\n${indent}}`;
                            }
                        }
                        
                        return String(value);
                    }
                    
                    const result = format(decoded);
                    return result;
                    
                } catch (e) {
                    return `CBOR 디코딩 오류: ${e.message}`;
                }
            };

            // 디코딩 로직 파이프라인
            useEffect(() => {
                const processInput = async () => {
                    // --- 초기화 ---
                    setOutput('');
                    setEncoding('');
                    setError(null);
                    setDataFormat(null);
                    setBinaryFormat(null);
                    setImageInfo(null);
                    setCborDiagnostic('');
                    setBeautified('');
                    setSyntaxError(null);
                    setSyntaxErrorLine(null);

                    if (input.length === 0) {
                        return;
                    }

                    // --- 1. 인코딩 감지 및 1차 디코딩 ---
                    const decodedResult = detectEncoding(input);

                    if (!decodedResult || !decodedResult.matched || !decodedResult.decoded) {
                        setError(t('messages.cannotDecode'));
                        setEncoding(decodedResult.encoding || '');
                        return;
                    }
                    
                    setOutput(decodedResult.decoded);
                    setEncoding(decodedResult.encoding);

                // --- CBOR 특별 처리 ---
                if (decodedResult.encoding === 'CBOR') {
                    setBinaryFormat('cbor');
                    
                    // CBOR 진단 정보 설정
                    try {
                        const cborBytes = binStringToUint8(input);
                        const diagnostic = toCborDiagnostic(cborBytes);
                        setCborDiagnostic(diagnostic);
                    } catch (e) {
                        // 진단 정보 생성 실패 시 무시
                    }
                    
                    // 디코딩된 결과가 이미지인지 확인
                    const imageResult = await sniffImage(decodedResult.decoded);
                    
                    if (imageResult) {
                        setDataFormat('binary');
                        setBinaryFormat('image');
                        
                        // 이미지 미리보기 설정
                        const { mime, ext } = imageResult;
                        let src = '';
                        if (mime === 'image/svg+xml') {
                            src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(decodedResult.decoded)));
                        } else {
                            src = 'data:' + mime + ';base64,' + binaryStringToBase64(decodedResult.decoded);
                        }
                        setImageInfo({ src, mime, ext });
                        setEncoding(prev => `${prev}-${ext.toUpperCase()}`);
                        
                        return; // CBOR-이미지 처리 완료
                    } else {
                        // 일반 텍스트나 다른 데이터
                        setDataFormat('text');
                        return; // CBOR 처리 완료, 추가 포맷 판별 불필요
                    }
                }

                // --- 2. 데이터 포맷 판별 (JSON, XML, Binary, Text) ---
                const format = await findDataFormat(decodedResult.decoded);
                setDataFormat(format);

                if (format === 'json' || format === 'xml') {
                    // --- 3a. JSON/XML 뷰티파이 ---
                    let beautifiedStr = '';
                    let syntaxErr = null;
                    let syntaxErrLine = null;

                    if (format === 'json') {
                        try {
                            const parsed = JSON.parse(decodedResult.decoded);
                            beautifiedStr = JSON.stringify(parsed, null, 2);
                        } catch (e) {
                            syntaxErr = e.message;
                            const match = e.message.match(/at position (\d+)/);
                            if (match) {
                                const pos = parseInt(match[1], 10);
                                syntaxErrLine = decodedResult.decoded.slice(0, pos).split('\n').length;
                            }
                        }
                    } else if (format === 'xml') {
                        beautifiedStr = formatXml(decodedResult.decoded);
                        const xmlCheck = validateXml(decodedResult.decoded);
                        if (!xmlCheck.valid) {
                            syntaxErr = xmlCheck.error;
                            syntaxErrLine = xmlCheck.errorLine;
                        }
                    }
                    setBeautified(beautifiedStr);
                    setSyntaxError(syntaxErr);
                    setSyntaxErrorLine(syntaxErrLine);

                } else if (format === 'binary' || decodedResult.isBinary) {
                    // --- 3b. 바이너리 포맷 판별 (Image, CBOR, 기타) ---
                    
                    // 모든 바이너리 데이터에 대해 이미지 감지 수행
                    const imageResult = await sniffImage(decodedResult.decoded);
                    
                    if (imageResult) {
                        setDataFormat('binary');
                        setBinaryFormat('image');
                        
                        // 이미지 미리보기 설정
                        const { mime, ext } = imageResult;
                        let src = '';
                        if (mime === 'image/svg+xml') {
                            src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(decodedResult.decoded)));
                        } else {
                            src = 'data:' + mime + ';base64,' + binaryStringToBase64(decodedResult.decoded);
                        }
                        setImageInfo({ src, mime, ext });
                        setEncoding(prev => `${prev}-${ext.toUpperCase()}`);
                        
                        return; // 이미지 처리 완료
                    }
                    
                    // 이미지가 아닌 경우 다른 바이너리 포맷 확인
                    const binFormat = await findBinaryFormat(decodedResult.decoded);
                    setBinaryFormat(binFormat.type);

                    if (binFormat.type === 'cbor') {
                        const cborBytes = binStringToUint8(decodedResult.decoded);
                        const diagnostic = toCborDiagnostic(cborBytes);
                        setCborDiagnostic(diagnostic);
                        setEncoding(prev => `${prev}-CBOR`);
                    }
                }
                };
                
                processInput();
            }, [input, language]);

            // 인코딩 입력 변화
            useEffect(() => {
                if (!encodeInput) {
                    setEncodeResult('');
                    setEncodeHexResult('');
                    return;
                }
                
                const result = encodeText(encodeInput, encodeType);
                setEncodeResult(result);
                
                // CBOR 인코딩인 경우 hex 결과도 생성
                if (encodeType === 'CBOR' && result) {
                    try {
                        // Binary 결과를 hex로 변환
                        const hexResult = Array.from(result)
                            .map(c => c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase())
                            .join(' ');
                        setEncodeHexResult(hexResult);
                    } catch (e) {
                        setEncodeHexResult('');
                    }
                } else {
                    setEncodeHexResult('');
                }
            }, [encodeInput, encodeType]);

            // Chip 목록은 레지스트리에서 가져오기
            const encoderLabels = Codecs.getEncoderLabels();

            // 언어 로딩 중일 때 로딩 표시
            if (!isLanguageLoaded) {
                return React.createElement('div', {
                    style: {
                        display: 'flex',
                        justifyContent: 'center',
                        alignItems: 'center',
                        height: '100vh',
                        fontSize: '16px'
                    }
                }, 'Loading...');
            }

            return (
                React.createElement(Grid, { container: true, spacing: 2, justifyContent: "center", alignItems: "center" },
                    React.createElement(Grid, { item: true, xs: 12, sm: 11, md: 8, lg: 6 },
                        React.createElement(Paper, { 
                            elevation: 3, 
                            style: { padding: '28px 20px' },
                            className: 'mobile-paper',
                            ref: paperRef 
                        },
                            React.createElement(Typography, { 
                                variant: "h4", 
                                component: "h1", 
                                gutterBottom: true, 
                                align: "center",
                                sx: {
                                    fontSize: { xs: '1.75rem', sm: '1.875rem', md: '2.125rem' },
                                    mb: { xs: 2, md: 3 },
                                    mt: { xs: 2, md: 0 }, // 모바일에서 상단 여백 조정
                                    lineHeight: { xs: 1.3, md: 1.2 },
                                    fontWeight: { xs: 600, md: 700 }
                                }
                            }, t('title')),
                            // 상단 보안/프라이버시 안내 강조 배너
                            React.createElement(MaterialUI.Alert, {
                                severity: "info",
                                variant: "outlined",
                                sx: {
                                    mb: { xs: 1.5, md: 2 },
                                    display: 'flex',
                                    alignItems: 'center',
                                    borderWidth: 1.5,
                                    borderColor: '#1976d2',
                                    color: '#1976d2',
                                    backgroundColor: 'transparent',
                                    borderRadius: 2,
                                    fontSize: { xs: '0.9rem', md: '1rem' },
                                    padding: { xs: '12px 16px', md: '16px' },
                                    '& .MuiTypography-body2': {
                                        fontSize: { xs: '0.9rem', md: '0.875rem' }
                                    },
                                    '& .MuiTypography-caption': {
                                        fontSize: { xs: '0.8rem', md: '0.75rem' }
                                    }
                                },
                                icon: React.createElement("span", { className: "material-icons", style: { color: '#1976d2' } }, "shield")
                            },
                                React.createElement(Box, { sx: { display: 'flex', flexDirection: 'column' } },
                                    React.createElement(Typography, { variant: "body2", sx: { fontWeight: 700 } }, t('common.privacyNote')),
                                )
                            ),
                            // 지원 인코딩 목록: 선택 UI 느낌을 제거한 배지(pill) 스타일
                            React.createElement(Box, { 
                                sx: { 
                                    display: 'flex', 
                                    flexWrap: 'wrap', 
                                    justifyContent: 'center', 
                                    mb: { xs: 1.5, md: 2 }, 
                                    gap: { xs: 0.5, md: 1 },
                                    px: { xs: 1, md: 0 }
                                } 
                            },
                                React.createElement(Box, {
                                    sx: {
                                        px: { xs: 1, md: 1.25 }, 
                                        py: { xs: 0.375, md: 0.5 }, 
                                        borderRadius: 9999,
                                        bgcolor: '#e3f2fd', 
                                        color: '#1976d2',
                                        fontSize: { xs: 10, md: 12 }, 
                                        fontWeight: 600
                                    }
                                }, t('common.supportedEncodings')),
                                [
                                    "CBOR",
                                    "Base64",
                                    "Base64URL",
                                    "Base32",
                                    "Hex (Base16)",
                                    "UTF-8",
                                    "ASCII",
                                    "URL Encoding",
                                    "HTML Entities",
                                    "Unicode Escape (\\uXXXX)",
                                    "Quoted-Printable",
                                    "Plain Text"
                                ].map(label =>
                                    React.createElement(Box, {
                                        key: label,
                                        sx: {
                                            px: { xs: 0.75, md: 1.25 }, 
                                            py: { xs: 0.25, md: 0.5 }, 
                                            borderRadius: 9999,
                                            bgcolor: '#f5f7fa', 
                                            color: 'text.secondary',
                                            border: '1px solid #e0e0e0',
                                            fontSize: { xs: 9, md: 12 },
                                            cursor: 'default',
                                            pointerEvents: 'none'
                                        }
                                    }, label)
                                )
                            ),
                            React.createElement(Divider, { style: { margin: '10px 0 18px 0' } }),
                            React.createElement(Tabs, {
                                value: tab,
                                onChange: (e, v) => setTab(v),
                                centered: true,
                                sx: { 
                                    mb: 2,
                                    '& .MuiTab-root': commonStyles.tab
                                }
                            },
                                React.createElement(Tab, { label: t('tabs.decoder') }),
                                React.createElement(Tab, { label: t('tabs.encoder') })
                            ),

                            // ----------------- 디코딩 탭 -----------------
                            tab === 0 && React.createElement(Box, null,
                                React.createElement(Typography, { variant: "body2", color: "textSecondary", align: "center", style: { marginBottom: 16 } },
                                    t('decoder.description')
                                ),
                                // 입력 초기화 및 파일 로드 버튼
                                React.createElement(Box, { sx: { textAlign: 'right', mb: 2, display: 'flex', justifyContent: 'flex-end', gap: 1.5 } },
                                    React.createElement(
                                        MaterialUI.Button,
                                        {
                                            variant: "outlined",
                                            color: "primary",
                                            size: "small",
                                            startIcon: React.createElement("span", { className: "material-icons" }, "upload_file"),
                                            onClick: () => handleFileSelect(setInput),
                                            sx: commonStyles.smallButton
                                        },
                                        t('buttons.fileLoad')
                                    ),
                                    React.createElement(
                                        MaterialUI.Button,
                                        {
                                            variant: "outlined",
                                            color: "secondary",
                                            size: "small",
                                            startIcon: React.createElement("span", { className: "material-icons" }, "clear"),
                                            onClick: () => setInput(''),
                                            disabled: !input,
                                            sx: commonStyles.smallButton
                                        },
                                        t('buttons.inputClear')
                                    )
                                ),
                                // 1. 디코딩 입력 (드래그앤드롭 지원 + 드래그오버 UI)
                                React.createElement(Box, {
                                    sx: { position: 'relative', mb: 3, borderRadius: 2 },
                                    onDrop: (e) => handleFileDrop(e, setInput).finally(() => setIsDragOverInput(false)),
                                    onDragOver: (e) => { e.preventDefault(); e.stopPropagation(); setIsDragOverInput(true); },
                                    onDragLeave: (e) => { e.preventDefault(); e.stopPropagation(); setIsDragOverInput(false); }
                                },
                                    React.createElement(TextField, {
                                        label: t('decoder.inputLabel'),
                                        variant: "outlined",
                                        fullWidth: true,
                                        multiline: true,
                                        rows: 8,
                                        value: input,
                                        onChange: e => setInput(e.target.value),
                                        placeholder: t('decoder.inputPlaceholder'),
                                        InputLabelProps: { shrink: true },
                                        inputRef: inputRef,
                                        inputProps: {
                                            onDrop: (e) => handleFileDrop(e, setInput).finally(() => setIsDragOverInput(false)),
                                            onDragOver: (e) => { e.preventDefault(); e.stopPropagation(); setIsDragOverInput(true); },
                                            onDragLeave: (e) => { e.preventDefault(); e.stopPropagation(); setIsDragOverInput(false); }
                                        },
                                        sx: {
                                            '& .MuiInputLabel-root': {
                                                fontSize: { xs: '1rem', md: '0.875rem' }
                                            },
                                            '& .MuiInputBase-input': {
                                                fontSize: { xs: '0.95rem', md: '0.875rem' },
                                                lineHeight: { xs: 1.4, md: 1.43 }
                                            },
                                            '& .MuiInputBase-root': {
                                                fontSize: { xs: '0.95rem', md: '0.875rem' }
                                            }
                                        },
                                        sx: {
                                            ...commonStyles.inputField,
                                            ...commonStyles.dragBackground(isDragOverInput)
                                        }
                                    }),
                                    isDragOverInput && React.createElement('div', {
                                        className: 'drag-overlay'
                                    },
                                        React.createElement('div', {
                                            className: 'drag-message'
                                        },
                                            React.createElement("span", { className: "material-icons", style: { fontSize: 28, marginRight: 8 } }, MATERIAL_ICON_UPLOAD),
                                            getDragMessage()
                                        )
                                    ),
                                    React.createElement('span', {
                                        style: {
                                            position: 'absolute',
                                            right: 16,
                                            bottom: 10,
                                            fontSize: 13,
                                            color: '#888',
                                            background: '#fafdff',
                                            padding: '0 6px'
                                        }
                                    }, `${bytesLen(input)} bytes`)
                                ),
                                // 감지된 인코딩 정보
                                encoding && React.createElement(MaterialUI.Alert, {
                                    severity: "info",
                                    variant: "outlined",
                                    sx: {
                                        mb: 1,
                                        display: 'flex',
                                        alignItems: 'center',
                                        borderWidth: 1.5,
                                        borderColor: encoding === 'Plain Text' ? '#757575' : '#1976d2',
                                        color: encoding === 'Plain Text' ? '#757575' : '#1976d2',
                                        backgroundColor: 'transparent',
                                        borderRadius: 2,
                                        fontSize: { xs: '0.85rem', md: '0.875rem' },
                                        padding: { xs: '8px 12px', md: '10px 14px' },
                                        '& .MuiTypography-body2': {
                                            fontSize: { xs: '0.85rem', md: '0.875rem' }
                                        }
                                    },
                                    icon: React.createElement("span", { 
                                        className: "material-icons", 
                                        style: { 
                                            color: encoding === 'Plain Text' ? '#757575' : '#1976d2',
                                            fontSize: '18px'
                                        } 
                                    }, "info")
                                },
                                    React.createElement(Typography, { 
                                        variant: "body2", 
                                        sx: { fontWeight: 600 } 
                                    }, `${t('decoder.encodingTypeLabel')}: ${encoding}`)
                                ),
                                // 복사/파일저장 버튼들
                                React.createElement(Box, { 
                                    sx: { 
                                        mb: 2, 
                                        display: 'flex',
                                        flexWrap: 'wrap',
                                        alignItems: 'center',
                                        justifyContent: 'flex-end',
                                        gap: 1
                                    } 
                                },
                                    React.createElement(
                                        Tooltip,
                                        { title: t('decoder.copyTooltip') },
                                        React.createElement(
                                            'span', // Add span wrapper
                                            { style: { display: 'inline-block' } },
                                            React.createElement(
                                                MaterialUI.Button,
                                                {
                                                    size: "small",
                                                    color: "primary",
                                                    variant: "outlined",
                                                    startIcon: React.createElement("span", { className: "material-icons" }, "content_copy"),
                                                    onClick: () => handleCopy(output, dataFormat === 'binary'),
                                                    sx: { 
                                                        ...commonStyles.smallButton
                                                    },
                                                    disabled: !output
                                                },
                                                t('buttons.copy')
                                            )
                                        )
                                    ),
                                    React.createElement(
                                        Tooltip,
                                        { title: t('decoder.downloadTooltip') },
                                        React.createElement(
                                            'span', // Add span wrapper
                                            { style: { display: 'inline-block' } },
                                            React.createElement(
                                                MaterialUI.Button,
                                                {
                                                    size: "small",
                                                    color: "secondary",
                                                    variant: "outlined",
                                                    startIcon: React.createElement("span", { className: "material-icons" }, "download"),
                                                    onClick: () => {
                                                        if (dataFormat === 'binary') {
                                                            handleDownload(output, 'binary_result.bin', true);
                                                        } else {
                                                            const encodingType = encoding.toLowerCase().replace(/[^a-z0-9]/g, '_');
                                                            handleDownload(output, `decoded_${encodingType}_result.txt`, false);
                                                        }
                                                    },
                                                    sx: commonStyles.smallButton,
                                                    disabled: !output
                                                },
                                                t('buttons.download')
                                            )
                                        )
                                    )
                                ),
                                // 디코딩 결과 (원본)
                                React.createElement(Box, { sx: { position: 'relative' } },
                                    error === t('messages.cannotDecode') ? (
                                        React.createElement('div', {
                                            style: {
                                                minHeight: 220,
                                                maxHeight: 320,
                                                background: '#fff3e0',
                                                color: '#c62828',
                                                borderRadius: 6,
                                                padding: 32,
                                                fontSize: 18,
                                                fontWeight: 500,
                                                display: 'flex',
                                                flexDirection: 'column',
                                                alignItems: 'center',
                                                justifyContent: 'center',
                                                marginBottom: '20px',
                                                border: '1.5px solid #ffc107'
                                            }
                                        },
                                            React.createElement('div', null, t('messages.cannotDecode')),
                                            encoding && React.createElement('div', {
                                                style: {
                                                    marginTop: 18,
                                                    fontSize: 15,
                                                    color: '#1976d2',
                                                    fontWeight: 400,
                                                    background: '#e3f2fd',
                                                    borderRadius: 4,
                                                    padding: '6px 16px'
                                                }
                                            }, `입력 데이터 형식: ${encoding}`)
                                        )
                                    ) : (
                                        dataFormat === 'binary' && !imageInfo && binaryFormat !== 'cbor'
                                            ? React.createElement(TextField, {
                                                label: t('decoder.binaryOutputLabel'),
                                                variant: "outlined",
                                                fullWidth: true,
                                                multiline: true,
                                                rows: 8,
                                                value: output,
                                                InputLabelProps: { shrink: true },
                                                inputRef: outputRef,
                                                style: { marginBottom: '20px', background: "#f0f0f0", fontFamily: 'Consolas, monospace' },
                                                InputProps: { 
                                                    readOnly: true,
                                                    style: { fontFamily: 'Consolas, monospace' }
                                                },
                                                sx: {
                                                    '& .MuiInputLabel-root': {
                                                        fontSize: { xs: '1rem', md: '0.875rem' }
                                                    },
                                                    '& .MuiInputBase-input': {
                                                        fontSize: { xs: '0.9rem', md: '0.8125rem' },
                                                        lineHeight: { xs: 1.4, md: 1.43 }
                                                    }
                                                }
                                            })
                                            : React.createElement(TextField, {
                                                label: t('decoder.outputLabel'),
                                                variant: "outlined",
                                                fullWidth: true,
                                                multiline: true,
                                                rows: 8,
                                                value: output,
                                                InputLabelProps: { shrink: true },
                                                inputRef: outputRef,
                                                style: { marginBottom: '20px', background: "#fafdff" },
                                                InputProps: { readOnly: true },
                                                sx: {
                                                    '& .MuiInputLabel-root': {
                                                        fontSize: { xs: '1rem', md: '0.875rem' }
                                                    },
                                                    '& .MuiInputBase-input': {
                                                        fontSize: { xs: '0.95rem', md: '0.875rem' },
                                                        lineHeight: { xs: 1.4, md: 1.43 }
                                                    }
                                                }
                                            })
                                    ),
                                    React.createElement('span', {
                                        style: {
                                            position: 'absolute',
                                            right: 16,
                                            bottom: 10,
                                            fontSize: 13,
                                            color: '#888',
                                            background: '#fafdff',
                                            padding: '0 6px'
                                        }
                                    }, `${bytesLen(output)} bytes`),

                                    // 이미지 미리보기 및 다운로드 버튼
                                    (() => {
                                        if (dataFormat === 'binary' && binaryFormat === 'image' && imageInfo) {
                                            return React.createElement(Box, { sx: { mt: 2, mb: 2 } },
                                                React.createElement(Typography, { variant: "subtitle2", sx: { mb: 1, fontWeight: 'bold' } }, `${t('decoder.imageViewLabel')} (${imageInfo.mime})`),
                                                // 이미지 저장 버튼 (메인 스타일과 동일한 위치)
                                                React.createElement(Box, { sx: { mb: 2, textAlign: 'right' } },
                                                    React.createElement(
                                                        Tooltip,
                                                        { title: t('decoder.imageSaveTooltip') },
                                                        React.createElement(
                                                            'span',
                                                            { style: { display: 'inline-block' } },
                                                            React.createElement(
                                                                MaterialUI.Button,
                                                                {
                                                                    size: "small",
                                                                    color: "secondary",
                                                                    variant: "outlined",
                                                                    startIcon: React.createElement("span", { className: "material-icons" }, "download"),
                                                                    onClick: () => {
                                                                        const a = document.createElement('a');
                                                                        a.href = imageInfo.src;
                                                                        a.download = `decoded_image.${imageInfo.ext || 'png'}`;
                                                                        document.body.appendChild(a);
                                                                        a.click();
                                                                        document.body.removeChild(a);
                                                                        showToast(t('imageSaveSuccess'), 'success');
                                                                    },
                                                                    sx: {
                                                                        ...commonStyles.smallButton
                                                                    }
                                                                },
                                                                t('buttons.download')
                                                            )
                                                        )
                                                    )
                                                ),
                                                React.createElement(Box, { sx: { textAlign: 'center' } },
                                                    React.createElement('img', {
                                                        src: imageInfo.src,
                                                        alt: "Decoded Image",
                                                        style: { maxWidth: '100%', maxHeight: 300, borderRadius: 8, border: '1px solid #eee', background: '#fff', display: 'block', margin: '0 auto' }
                                                    })
                                                )
                                            );
                                        }
                                        return null;
                                    })()
                                ),

                                // beautify / syntax checks
                                (dataFormat === 'json' || dataFormat === 'xml') && beautified &&
                                    React.createElement(Box, { sx: { mt: 2 } },
                                        React.createElement(Typography, { variant: "subtitle1", sx: { mb: 1, fontWeight: 'bold' } },
                                            t('decoder.beautifyLabel') + (syntaxError ? ' (Syntax Error)' : '')
                                        ),
                                        renderBeautifiedWithError(beautified, dataFormat, syntaxErrorLine)
                                    ),

                                // CBOR Diagnostic Notation 결과
                                dataFormat === 'binary' && binaryFormat === 'cbor' && cborDiagnostic && React.createElement(Box, { sx: { mt: 2 } },
                                    // 복사/다운로드 버튼들 (메인 스타일과 동일)
                                    React.createElement(Box, { 
                                        sx: { 
                                            mb: 2, 
                                            display: 'flex',
                                            flexWrap: 'wrap',
                                            alignItems: 'center',
                                            justifyContent: 'flex-end',
                                            gap: 1
                                        } 
                                    },
                                        React.createElement(
                                            Tooltip,
                                            { title: "CBOR 진단 표기 결과 복사" },
                                            React.createElement(
                                                'span',
                                                { style: { display: 'inline-block' } },
                                                React.createElement(
                                                    MaterialUI.Button,
                                                    {
                                                        size: "small",
                                                        color: "primary",
                                                        variant: "outlined",
                                                        startIcon: React.createElement("span", { className: "material-icons" }, "content_copy"),
                                                        onClick: () => handleCopy(cborDiagnostic),
                                                        sx: commonStyles.smallButton,
                                                        disabled: !cborDiagnostic
                                                    },
                                                    t('buttons.copy')
                                                )
                                            )
                                        ),
                                        React.createElement(
                                            Tooltip,
                                            { title: "CBOR 진단 표기 결과를 파일로 저장" },
                                            React.createElement(
                                                'span',
                                                { style: { display: 'inline-block' } },
                                                React.createElement(
                                                    MaterialUI.Button,
                                                    {
                                                        size: "small",
                                                        color: "secondary",
                                                        variant: "outlined",
                                                        startIcon: React.createElement("span", { className: "material-icons" }, "download"),
                                                        onClick: () => handleDownload(cborDiagnostic, 'cbor_diagnostic_result.txt'),
                                                        sx: commonStyles.smallButton,
                                                        disabled: !cborDiagnostic
                                                    },
                                                    t('buttons.download')
                                                )
                                            )
                                        )
                                    ),
                                    React.createElement(Box, {
                                        sx: {
                                            position: 'relative',
                                            border: '1px solid #e0e0e0',
                                            borderRadius: 1,
                                            backgroundColor: '#f8f9fa'
                                        }
                                    },
                                        React.createElement(TextField, {
                                            label: "CBOR Diagnostic Notation",
                                            value: cborDiagnostic,
                                            variant: "outlined",
                                            fullWidth: true,
                                            multiline: true,
                                            rows: 6,
                                            InputProps: { readOnly: true },
                                            sx: {
                                                '& .MuiOutlinedInput-root': {
                                                    fontFamily: 'monospace',
                                                    fontSize: '14px',
                                                    backgroundColor: '#ffffff'
                                                }
                                            }
                                        })
                                    )
                                )
                            ),

                            // ----------------- 인코딩 탭 -----------------
                            tab === 1 && React.createElement(Box, null,
                                React.createElement(Typography, { variant: "body2", color: "textSecondary", align: "center", style: { marginBottom: 16 } },
                                    t('encoder.description')
                                ),
                                // 입력 초기화 및 파일 로드 버튼
                                React.createElement(Box, { sx: { textAlign: 'right', mb: 2, display: 'flex', justifyContent: 'flex-end', gap: 1.5 } },
                                    React.createElement(
                                        MaterialUI.Button,
                                        {
                                            variant: "outlined",
                                            color: "primary",
                                            size: "small",
                                            startIcon: React.createElement("span", { className: "material-icons" }, "upload_file"),
                                            onClick: () => handleFileSelect(setEncodeInput),
                                            sx: commonStyles.smallButton
                                        },
                                        t('buttons.fileLoad')
                                    ),
                                    React.createElement(
                                        MaterialUI.Button,
                                        {
                                            variant: "outlined",
                                            color: "secondary",
                                            size: "small",
                                            startIcon: React.createElement("span", { className: "material-icons" }, "clear"),
                                            onClick: () => setEncodeInput(''),
                                            disabled: !encodeInput,
                                            sx: commonStyles.smallButton
                                        },
                                        t('buttons.inputClear')
                                    )
                                ),
                                // 1. 인코딩 입력 (드래그앤드롭 지원 + 드래그오버 UI)
                                React.createElement(Box, {
                                    sx: { position: 'relative', mb: 3, borderRadius: 2 },
                                    onDrop: (e) => handleFileDrop(e, setEncodeInput).finally(() => setIsDragOverEncode(false)),
                                    onDragOver: (e) => { e.preventDefault(); e.stopPropagation(); setIsDragOverEncode(true); },
                                    onDragLeave: (e) => { e.preventDefault(); e.stopPropagation(); setIsDragOverEncode(false); }
                                },
                                    React.createElement(TextField, {
                                        label: t('encoder.textInputLabel'),
                                        variant: "outlined",
                                        fullWidth: true,
                                        multiline: true,
                                        rows: 8,
                                        value: encodeInput,
                                        onChange: e => setEncodeInput(e.target.value),
                                        placeholder: t('encoder.inputPlaceholder'),
                                        InputLabelProps: { shrink: true },
                                        inputRef: encodeInputRef,
                                        inputProps: {
                                            onDrop: (e) => handleFileDrop(e, setEncodeInput).finally(() => setIsDragOverEncode(false)),
                                            onDragOver: (e) => { e.preventDefault(); e.stopPropagation(); setIsDragOverEncode(true); },
                                            onDragLeave: (e) => { e.preventDefault(); e.stopPropagation(); setIsDragOverEncode(false); }
                                        },
                                        sx: {
                                            ...commonStyles.inputField,
                                            ...commonStyles.dragBackground(isDragOverEncode)
                                        }
                                    }),
                                    isDragOverEncode && React.createElement('div', {
                                        className: 'drag-overlay'
                                    },
                                        React.createElement('div', {
                                            className: 'drag-message'
                                        },
                                            React.createElement("span", { className: "material-icons", style: { fontSize: 28, marginRight: 8 } }, MATERIAL_ICON_UPLOAD),
                                            getDragMessage()
                                        )
                                    ),
                                    React.createElement('span', {
                                        style: {
                                            position: 'absolute',
                                            right: 16,
                                            bottom: 10,
                                            fontSize: 13,
                                            color: '#888',
                                            background: '#fafdff',
                                            padding: '0 6px'
                                        }
                                    }, `${bytesLen(encodeInput)} bytes`)
                                ),
                                // 인코딩 알고리즘 리스트 (레지스트리 기반)
                                React.createElement(Box, { sx: { mb: 1 } },
                                    React.createElement(Typography, {
                                        variant: "subtitle2",
                                        sx: { display: 'flex', alignItems: 'center', fontWeight: 700, color: 'primary.main' }
                                    },
                                        React.createElement("span", { className: "material-icons", style: { fontSize: 18, marginRight: 6 } }, "tune"),
                                        t('common.selectEncoding')
                                    )
                                ),
                                React.createElement(Box, { sx: { mb: 2, display: 'flex', flexWrap: 'wrap', gap: 1 } },
                                    encoderLabels.map(type =>
                                        React.createElement(Chip, {
                                            key: type,
                                            label: type,
                                            size: "small",
                                            variant: "outlined",
                                            sx: {
                                                mr: 1, mb: 1,
                                                borderColor: encodeType === type ? 'primary.main' : '#e0e0e0',
                                                color: encodeType === type ? 'primary.main' : 'text.secondary',
                                                bgcolor: 'transparent',
                                                cursor: 'pointer',
                                                '&:hover': { bgcolor: '#fafafa' }
                                            },
                                            clickable: true,
                                            onClick: () => setEncodeType(type)
                                        })
                                    )
                                ),
                                // 선택된 인코딩 설명 (outlined Alert 스타일)
                                React.createElement(MaterialUI.Alert, {
                                    severity: "info",
                                    variant: "outlined",
                                    sx: {
                                        mb: 2,
                                        display: 'flex',
                                        alignItems: 'center',
                                        borderWidth: 1.5,
                                        borderColor: '#1976d2',
                                        color: '#1976d2',
                                        backgroundColor: 'transparent',
                                        borderRadius: 2
                                    },
                                    icon: React.createElement("span", { className: "material-icons", style: { color: '#1976d2' } }, "info")
                                },
                                    React.createElement(Box, { sx: { display: 'flex', flexDirection: 'column' } },
                                        React.createElement(Typography, { variant: "body2", sx: { fontWeight: 700 } }, t('encoder.algorithmDescription')),
                                        React.createElement(Typography, { variant: "caption" }, t('codecDescriptions.' + encodeType))
                                    )
                                ),

                                // 결과 복사
                                React.createElement(Box, { 
                                    sx: { 
                                        mb: 2, 
                                        display: 'flex',
                                        flexWrap: 'wrap',
                                        alignItems: 'center',
                                        justifyContent: 'flex-end',
                                        gap: 1
                                    } 
                                },
                                    React.createElement(
                                        Tooltip,
                                        { title: t('encoder.copyTooltip') },
                                        React.createElement(
                                            'span', // Add span wrapper
                                            { style: { display: 'inline-block' } },
                                            React.createElement(
                                                MaterialUI.Button,
                                                {
                                                    size: "small",
                                                    color: "primary",
                                                    variant: "outlined",
                                                    startIcon: React.createElement("span", { className: "material-icons" }, "content_copy"),
                                                    onClick: () => handleCopy(encodeResult, isBinaryString(encodeResult, 0.1)),
                                                    sx: commonStyles.smallButton,
                                                    disabled: !encodeResult
                                                },
                                                t('buttons.copy')
                                            )
                                        )
                                    ),
                                    React.createElement(
                                        Tooltip,
                                        { title: t('encoder.downloadTooltip') },
                                        React.createElement(
                                            'span', // Add span wrapper
                                            { style: { display: 'inline-block' } },
                                            React.createElement(
                                                MaterialUI.Button,
                                                {
                                                    size: "small",
                                                    color: "secondary",
                                                    variant: "outlined",
                                                    startIcon: React.createElement("span", { className: "material-icons" }, "download"),
                                                    onClick: () => {
                                                        const encodingType = encodeType.toLowerCase().replace(/[^a-z0-9]/g, '_');
                                                        if (encodeType === 'CBOR') {
                                                            handleDownload(encodeResult, `encoded_${encodingType}_result.cbor`, true);
                                                        } else {
                                                            handleDownload(encodeResult, `encoded_${encodingType}_result.txt`, false);
                                                        }
                                                    },
                                                    sx: commonStyles.smallButton,
                                                    disabled: !encodeResult
                                                },
                                                t('buttons.download')
                                            )
                                        )
                                    )
                                ),
                                React.createElement(TextField, {
                                    label: t('encoder.resultLabel'),
                                    variant: "outlined",
                                    fullWidth: true,
                                    multiline: true,
                                    rows: 8,
                                    value: encodeResult,
                                    InputLabelProps: { shrink: true },
                                    style: { marginBottom: '20px', background: "#fafdff" },
                                    InputProps: { readOnly: true }
                                }),
                                
                                // CBOR 인코딩 시 hex 결과 표시
                                encodeType === 'CBOR' && encodeHexResult ? React.createElement(Box, { sx: { mb: 2 } },
                                    React.createElement(Box, { 
                                        sx: { 
                                            mb: 1, 
                                            display: 'flex',
                                            flexWrap: 'wrap',
                                            alignItems: 'center',
                                            justifyContent: 'flex-end',
                                            gap: 1
                                        } 
                                    },
                                        React.createElement(
                                            Tooltip,
                                            { title: "Hex 결과 복사" },
                                            React.createElement(
                                                MaterialUI.Button,
                                                {
                                                    size: "small",
                                                    color: "secondary",
                                                    variant: "outlined",
                                                    startIcon: React.createElement("span", { className: "material-icons" }, "content_copy"),
                                                    onClick: () => handleCopy(encodeHexResult),
                                                    sx: commonStyles.smallButton,
                                                    disabled: !encodeHexResult
                                                },
                                                "Hex 복사"
                                            )
                                        ),
                                        React.createElement(
                                            Tooltip,
                                            { title: "Hex 결과를 텍스트 파일로 저장" },
                                            React.createElement(
                                                MaterialUI.Button,
                                                {
                                                    size: "small",
                                                    color: "secondary",
                                                    variant: "outlined",
                                                    startIcon: React.createElement("span", { className: "material-icons" }, "download"),
                                                    onClick: () => handleDownload(encodeHexResult, 'cbor_hex_result.txt'),
                                                    sx: commonStyles.smallButton,
                                                    disabled: !encodeHexResult
                                                },
                                                t('buttons.download')
                                            )
                                        )
                                    ),
                                    React.createElement(TextField, {
                                        label: "Hex 결과",
                                        variant: "outlined",
                                        fullWidth: true,
                                        multiline: true,
                                        rows: 4,
                                        value: encodeHexResult,
                                        InputLabelProps: { shrink: true },
                                        style: { marginBottom: '20px', background: "#fff8e1" },
                                        InputProps: { readOnly: true }
                                    })
                                ) : null,
                                
                            ),
                            
                            // 페이지 하단 언어 선택
                            React.createElement(Box, { 
                                sx: { 
                                    display: 'flex', 
                                    justifyContent: 'center', 
                                    mt: 4,
                                    mb: 2,
                                    pt: 3,
                                    borderTop: '1px solid #e0e0e0'
                                } 
                            },
                                React.createElement(MaterialUI.FormControl, { 
                                    sx: { 
                                        minWidth: { xs: 140, md: 120 },
                                        '& .MuiInputLabel-root': {
                                            fontSize: { xs: '0.9rem', md: '0.875rem' }
                                        },
                                        '& .MuiSelect-select': {
                                            padding: { xs: '8px 32px 8px 12px', md: '6px 24px 6px 8px' }
                                        }
                                    } 
                                },
                                    React.createElement(MaterialUI.InputLabel, { 
                                        id: "language-select-label",
                                        sx: { fontSize: { xs: '0.9rem', md: '0.875rem' } }
                                    }, t('common.language')),
                                    React.createElement(MaterialUI.Select, {
                                        labelId: "language-select-label",
                                        value: language,
                                        onChange: (event) => setLanguage(event.target.value),
                                        label: t('common.language'),
                                        size: "small",
                                        variant: "outlined",
                                        sx: { 
                                            fontSize: { xs: '0.9rem', md: '0.875rem' },
                                            '& .MuiSelect-icon': {
                                                fontSize: '1.2rem'
                                            }
                                        }
                                    },
                                        React.createElement(MaterialUI.MenuItem, { value: "ko", sx: { fontSize: '0.875rem' } }, 
                                            React.createElement(Box, { sx: { display: 'flex', alignItems: 'center', gap: 1 } },
                                                React.createElement('img', { 
                                                    src: 'https://flagcdn.com/16x12/kr.png',
                                                    alt: '한국',
                                                    style: { width: '16px', height: '12px' }
                                                }),
                                                React.createElement('span', null, t('common.korean'))
                                            )
                                        ),
                                        React.createElement(MaterialUI.MenuItem, { value: "en", sx: { fontSize: '0.875rem' } },
                                            React.createElement(Box, { sx: { display: 'flex', alignItems: 'center', gap: 1 } },
                                                React.createElement('img', { 
                                                    src: 'https://flagcdn.com/16x12/us.png',
                                                    alt: '미국',
                                                    style: { width: '16px', height: '12px' }
                                                }),
                                                React.createElement('span', null, t('common.english'))
                                            )
                                        ),
                                        React.createElement(MaterialUI.MenuItem, { value: "ja", sx: { fontSize: '0.875rem' } },
                                            React.createElement(Box, { sx: { display: 'flex', alignItems: 'center', gap: 1 } },
                                                React.createElement('img', { 
                                                    src: 'https://flagcdn.com/16x12/jp.png',
                                                    alt: '일본',
                                                    style: { width: '16px', height: '12px' }
                                                }),
                                                React.createElement('span', null, t('common.japanese'))
                                            )
                                        ),
                                        React.createElement(MaterialUI.MenuItem, { value: "zh-CN", sx: { fontSize: '0.875rem' } },
                                            React.createElement(Box, { sx: { display: 'flex', alignItems: 'center', gap: 1 } },
                                                React.createElement('img', { 
                                                    src: 'https://flagcdn.com/16x12/cn.png',
                                                    alt: '중국',
                                                    style: { width: '16px', height: '12px' }
                                                }),
                                                React.createElement('span', null, t('common.chinese_simplified'))
                                            )
                                        ),
                                        React.createElement(MaterialUI.MenuItem, { value: "zh-TW", sx: { fontSize: '0.875rem' } },
                                            React.createElement(Box, { sx: { display: 'flex', alignItems: 'center', gap: 1 } },
                                                React.createElement('img', { 
                                                    src: 'https://flagcdn.com/16x12/tw.png',
                                                    alt: '대만',
                                                    style: { width: '16px', height: '12px' }
                                                }),
                                                React.createElement('span', null, t('common.chinese_traditional'))
                                            )
                                        ),
                                        React.createElement(MaterialUI.MenuItem, { value: "es", sx: { fontSize: '0.875rem' } },
                                            React.createElement(Box, { sx: { display: 'flex', alignItems: 'center', gap: 1 } },
                                                React.createElement('img', { 
                                                    src: 'https://flagcdn.com/16x12/es.png',
                                                    alt: '스페인',
                                                    style: { width: '16px', height: '12px' }
                                                }),
                                                React.createElement('span', null, t('common.spanish'))
                                            )
                                        ),
                                        React.createElement(MaterialUI.MenuItem, { value: "fr", sx: { fontSize: '0.875rem' } },
                                            React.createElement(Box, { sx: { display: 'flex', alignItems: 'center', gap: 1 } },
                                                React.createElement('img', { 
                                                    src: 'https://flagcdn.com/16x12/fr.png',
                                                    alt: '프랑스',
                                                    style: { width: '16px', height: '12px' }
                                                }),
                                                React.createElement('span', null, t('common.french'))
                                            )
                                        ),
                                        React.createElement(MaterialUI.MenuItem, { value: "de", sx: { fontSize: '0.875rem' } },
                                            React.createElement(Box, { sx: { display: 'flex', alignItems: 'center', gap: 1 } },
                                                React.createElement('img', { 
                                                    src: 'https://flagcdn.com/16x12/de.png',
                                                    alt: '독일',
                                                    style: { width: '16px', height: '12px' }
                                                }),
                                                React.createElement('span', null, t('common.german'))
                                            )
                                        ),
                                        React.createElement(MaterialUI.MenuItem, { value: "ru", sx: { fontSize: '0.875rem' } },
                                            React.createElement(Box, { sx: { display: 'flex', alignItems: 'center', gap: 1 } },
                                                React.createElement('img', { 
                                                    src: 'https://flagcdn.com/16x12/ru.png',
                                                    alt: '러시아',
                                                    style: { width: '16px', height: '12px' }
                                                }),
                                                React.createElement('span', null, t('common.russian'))
                                            )
                                        ),
                                        React.createElement(MaterialUI.MenuItem, { value: "pt", sx: { fontSize: '0.875rem' } },
                                            React.createElement(Box, { sx: { display: 'flex', alignItems: 'center', gap: 1 } },
                                                React.createElement('img', { 
                                                    src: 'https://flagcdn.com/16x12/pt.png',
                                                    alt: '포르투갈',
                                                    style: { width: '16px', height: '12px' }
                                                }),
                                                React.createElement('span', null, t('common.portuguese'))
                                            )
                                        ),
                                        React.createElement(MaterialUI.MenuItem, { value: "it", sx: { fontSize: '0.875rem' } },
                                            React.createElement(Box, { sx: { display: 'flex', alignItems: 'center', gap: 1 } },
                                                React.createElement('img', { 
                                                    src: 'https://flagcdn.com/16x12/it.png',
                                                    alt: '이탈리아',
                                                    style: { width: '16px', height: '12px' }
                                                }),
                                                React.createElement('span', null, t('common.italian'))
                                            )
                                        )
                                    )
                                )
                            ),
                            
                            // 전역 Snackbar
                            React.createElement(
                                MaterialUI.Portal,
                                { container: document.body },
                                React.createElement(
                                    MaterialUI.Snackbar,
                                    {
                                        open: toast.open,
                                        autoHideDuration: 1000,
                                        onClose: handleToastClose,
                                        anchorOrigin: { vertical: 'bottom', horizontal: 'center' }
                                    },
                                    React.createElement(
                                        MaterialUI.Alert,
                                        { onClose: handleToastClose, severity: toast.severity, sx: { width: '100%' } },
                                        toast.message
                                    )
                                )
                            )
                        )
                    )
                )
            );
        }

        // React 앱을 I18nextProvider로 감싸서 렌더링
        const AppWithI18n = React.createElement(
            ReactI18next.I18nextProvider,
            { i18n: i18next },
            React.createElement(EncoderDecoderTabs)
        );
        
        ReactDOM.createRoot(document.getElementById('root')).render(AppWithI18n);

        // base64 helper 함수 (이미 위로 이동되어 주석만 남음)
    </script>
</body>
</html>
</html>