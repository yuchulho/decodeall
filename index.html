<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자동 인코딩 감지 & 디코더</title>
    <!-- Material UI CDN -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
    <style>
        body {
            font-family: 'Roboto', Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            min-height: 100vh;
        }
        #root {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
        }
        .json-key { color: #ffb300; }
        .json-string { color: #43a047; }
        .json-number { color: #29b6f6; }
        .json-boolean { color: #f06292; }
        .json-null { color: #bdbdbd; }
        .xml-tag { color: #64b5f6; }
        .xml-attr { color: #ffd54f; }
        .xml-attr-value { color: #81c784; }
        
        /* 모바일 반응형 스타일 */
        @media (max-width: 768px) {
            #root {
                align-items: flex-start;
                padding: 16px 8px;
            }
            .mobile-paper {
                padding: 20px 16px !important;
            }
            .mobile-title {
                font-size: 1.5rem !important;
                margin-bottom: 16px !important;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Material UI -->
    <script src="https://unpkg.com/@mui/material@5.15.15/umd/material-ui.development.js"></script>
    <!-- GSAP CDN -->
    <script src="https://unpkg.com/gsap@3.12.5/dist/gsap.min.js"></script>
    <!-- iconv-lite for charset decoding (browserified) -->
    <script src="https://cdn.jsdelivr.net/npm/iconv-lite@0.6.3/dist/iconv-lite.min.js"></script>
    <!-- CBOR decoder/encoder (inline implementation) -->
    <script>
        // 인라인 CBOR 구현체
        window.cborg = (function() {
            function decode(buffer) {
                const bytes = new Uint8Array(buffer);
                let offset = 0;
                
                function readUint(length) {
                    if (offset + length > bytes.length) {
                        throw new Error('Not enough data');
                    }
                    let result = 0;
                    for (let i = 0; i < length; i++) {
                        result = (result << 8) | bytes[offset++];
                    }
                    return result;
                }
                
                function readLength(additionalInfo) {
                    if (additionalInfo < 24) {
                        return additionalInfo;
                    } else if (additionalInfo === 24) {
                        return readUint(1);
                    } else if (additionalInfo === 25) {
                        return readUint(2);
                    } else if (additionalInfo === 26) {
                        return readUint(4);
                    } else if (additionalInfo === 27) {
                        const high = readUint(4);
                        const low = readUint(4);
                        if (high !== 0) {
                            throw new Error('64-bit lengths not supported');
                        }
                        return low;
                    } else {
                        throw new Error(`Invalid additional info: ${additionalInfo}`);
                    }
                }
                
                function parseItem() {
                    if (offset >= bytes.length) {
                        throw new Error('Unexpected end of CBOR data');
                    }
                    
                    const initialByte = bytes[offset++];
                    const majorType = (initialByte >> 5) & 0x7;
                    const additionalInfo = initialByte & 0x1f;
                    
                    switch (majorType) {
                        case 0: // unsigned integer
                            return readLength(additionalInfo);
                            
                        case 1: // negative integer
                            return -1 - readLength(additionalInfo);
                            
                        case 2: // byte string
                            const byteLength = readLength(additionalInfo);
                            if (offset + byteLength > bytes.length) {
                                throw new Error(`Not enough data for byte string`);
                            }
                            const byteArray = new Uint8Array(byteLength);
                            for (let i = 0; i < byteLength; i++) {
                                byteArray[i] = bytes[offset++];
                            }
                            return byteArray;
                            
                        case 3: // text string
                            const textLength = readLength(additionalInfo);
                            if (offset + textLength > bytes.length) {
                                throw new Error(`Not enough data for text string`);
                            }
                            const textBytes = new Uint8Array(textLength);
                            for (let i = 0; i < textLength; i++) {
                                textBytes[i] = bytes[offset++];
                            }
                            return new TextDecoder('utf-8').decode(textBytes);
                            
                        case 4: // array
                            const arrayLength = readLength(additionalInfo);
                            const array = [];
                            for (let i = 0; i < arrayLength; i++) {
                                array.push(parseItem());
                            }
                            return array;
                            
                        case 5: // map
                            const mapLength = readLength(additionalInfo);
                            const map = {};
                            for (let i = 0; i < mapLength; i++) {
                                const key = parseItem();
                                const value = parseItem();
                                map[key] = value;
                            }
                            return map;
                            
                        case 6: // semantic tag
                            const tag = readLength(additionalInfo);
                            const taggedValue = parseItem();
                            return {
                                "CBOR_TAG": tag,
                                "value": taggedValue
                            };
                            
                        case 7: // float/simple/break
                            if (additionalInfo < 20) {
                                return additionalInfo;
                            } else if (additionalInfo === 20) {
                                return false;
                            } else if (additionalInfo === 21) {
                                return true;
                            } else if (additionalInfo === 22) {
                                return null;
                            } else if (additionalInfo === 23) {
                                return undefined;
                            } else if (additionalInfo === 25) {
                                // half-precision float (16-bit)
                                const halfFloat = readUint(2);
                                const sign = (halfFloat & 0x8000) ? -1 : 1;
                                const exponent = (halfFloat & 0x7C00) >> 10;
                                const fraction = halfFloat & 0x03FF;
                                if (exponent === 0) {
                                    return sign * Math.pow(2, -14) * (fraction / 1024);
                                } else if (exponent === 31) {
                                    return fraction ? NaN : sign * Infinity;
                                } else {
                                    return sign * Math.pow(2, exponent - 15) * (1 + fraction / 1024);
                                }
                            } else if (additionalInfo === 26) {
                                // single-precision float (32-bit)
                                const floatBytes = new Uint8Array(4);
                                for (let i = 0; i < 4; i++) {
                                    floatBytes[i] = bytes[offset++];
                                }
                                const view = new DataView(floatBytes.buffer);
                                return view.getFloat32(0, false);
                            } else if (additionalInfo === 27) {
                                // double-precision float (64-bit)
                                const doubleBytes = new Uint8Array(8);
                                for (let i = 0; i < 8; i++) {
                                    doubleBytes[i] = bytes[offset++];
                                }
                                const view = new DataView(doubleBytes.buffer);
                                return view.getFloat64(0, false);
                            } else {
                                throw new Error(`Unsupported simple/float type: ${additionalInfo}`);
                            }
                            
                        default:
                            throw new Error(`Unknown major type: ${majorType}`);
                    }
                }
                
                return parseItem();
            }
            
            function encode(obj) {
                const result = [];
                
                function writeUint(value, length) {
                    const bytes = [];
                    for (let i = length - 1; i >= 0; i--) {
                        bytes.push((value >> (i * 8)) & 0xFF);
                    }
                    return bytes;
                }
                
                function encodeLength(majorType, length) {
                    if (length < 24) {
                        return [(majorType << 5) | length];
                    } else if (length < 256) {
                        return [(majorType << 5) | 24, length];
                    } else if (length < 65536) {
                        return [(majorType << 5) | 25, ...writeUint(length, 2)];
                    } else if (length < 4294967296) {
                        return [(majorType << 5) | 26, ...writeUint(length, 4)];
                    } else {
                        return [(majorType << 5) | 27, ...writeUint(length, 8)];
                    }
                }
                
                function encodeItem(item) {
                    if (typeof item === 'number' && Number.isInteger(item)) {
                        if (item >= 0) {
                            return encodeLength(0, item);
                        } else {
                            return encodeLength(1, -1 - item);
                        }
                    } else if (typeof item === 'string') {
                        const utf8 = new TextEncoder().encode(item);
                        return [...encodeLength(3, utf8.length), ...utf8];
                    } else if (typeof item === 'boolean') {
                        return [(7 << 5) | (item ? 21 : 20)];
                    } else if (item === null) {
                        return [(7 << 5) | 22];
                    } else if (item === undefined) {
                        return [(7 << 5) | 23];
                    } else if (Array.isArray(item)) {
                        let result = encodeLength(4, item.length);
                        for (const element of item) {
                            result = result.concat(encodeItem(element));
                        }
                        return result;
                    } else if (typeof item === 'object') {
                        const keys = Object.keys(item);
                        let result = encodeLength(5, keys.length);
                        for (const key of keys) {
                            result = result.concat(encodeItem(key));
                            result = result.concat(encodeItem(item[key]));
                        }
                        return result;
                    } else {
                        throw new Error(`Cannot encode type: ${typeof item}`);
                    }
                }
                
                return new Uint8Array(encodeItem(obj));
            }
            
            return { decode, encode };
        })();
        
        console.log("인라인 CBOR 구현체 로드 완료");
    </script>
    <script>
        // CBOR 라이브러리 로드 상태 확인
        window.addEventListener('load', function() {
            console.log("페이지 로드 완료. CBOR 라이브러리 상태 확인:");
            console.log("window.cborg:", typeof window.cborg, window.cborg);
            console.log("window.CBOR:", typeof window.CBOR, window.CBOR);
            console.log("window.cbor:", typeof window.cbor, window.cbor);
            console.log("cborg:", typeof cborg !== 'undefined' ? cborg : 'undefined');
            console.log("CBOR:", typeof CBOR !== 'undefined' ? CBOR : 'undefined');
        });
        
        const { useState, useEffect, useRef } = React;
        const {
            Box,
            Typography,
            TextField,
            Paper,
            Grid,
            Divider,
            Chip,
            Tooltip,
            IconButton,
            Tabs,
            Tab,
            FormControl,
            InputLabel,
            Select,
            MenuItem
        } = MaterialUI;

        // -------------------------
        // Utils (중복 제거 공통 함수)
        // -------------------------
        function bytesLen(str) {
            try { return new TextEncoder().encode(str || '').length; } catch { return (str || '').length; }
        }
        function isBinaryString(str, threshold = 0.2) {
            if (!str) return false;
            let nonPrintable = 0;
            for (let i = 0; i < str.length; ++i) {
                const code = str.charCodeAt(i);
                if ((code < 0x09 || (code > 0x0D && code < 0x20) || code === 0x7F)) nonPrintable++;
            }
            return (nonPrintable / str.length) > threshold;
        }
        function toHexView(binaryStr) {
            const bytes = binaryStr ? Array.from(binaryStr).map(c => c.charCodeAt(0)) : [];
            let lines = [];
            for (let i = 0; i < bytes.length; i += 16) {
                let hex = bytes.slice(i, i + 16).map(b => b.toString(16).padStart(2, '0')).join(' ');
                let ascii = bytes.slice(i, i + 16).map(b => (b >= 32 && b <= 126 ? String.fromCharCode(b) : '.')).join('');
                lines.push(hex.padEnd(16 * 3) + '  ' + ascii);
            }
            return lines.join('\n');
        }
        
        // Base64/바이너리 변환 유틸리티 함수들
        function base64ToUint8(base64Str) {
            const binaryStr = atob(base64Str.replace(/\s/g, ''));
            const bytes = new Uint8Array(binaryStr.length);
            for (let i = 0; i < binaryStr.length; i++) {
                bytes[i] = binaryStr.charCodeAt(i) & 0xFF;
            }
            return bytes;
        }
        
        function uint8ToBinString(uint8Array) {
            let binaryString = '';
            for (let i = 0; i < uint8Array.length; i++) {
                binaryString += String.fromCharCode(uint8Array[i] & 0xFF);
            }
            return binaryString;
        }
        
        function binStringToUint8(binaryStr) {
            const bytes = new Uint8Array(binaryStr.length);
            for (let i = 0; i < binaryStr.length; i++) {
                bytes[i] = binaryStr.charCodeAt(i) & 0xFF;
            }
            return bytes;
        }
        
        // 파일 다운로드 함수
        function downloadTextFile(content, filename = 'decoded_result.txt') {
            try {
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                return true;
            } catch (error) {
                return false;
            }
        }

        // 바이너리 파일 다운로드 함수 (CBOR 등 바이너리 데이터용)
        function downloadBinaryFile(binaryString, filename = 'binary_result.bin') {
            try {
                // 바이너리 문자열을 Uint8Array로 변환
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i) & 0xFF;
                }
                
                const blob = new Blob([bytes], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                return true;
            } catch (error) {
                return false;
            }
        }
        async function handleFileDrop(e, setValue) {
            e.preventDefault();
            e.stopPropagation();
            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                const file = e.dataTransfer.files[0];
                if (file.type.startsWith('text/')) {
                    const text = await file.text();
                    setValue(text);
                } else {
                    // 바이너리 파일: 바이너리 문자열 로딩 (개선된 방식)
                    const arrayBuffer = await file.arrayBuffer();
                    const bytes = new Uint8Array(arrayBuffer);
                    let binaryString = '';
                    // 바이트 값을 정확히 보존하기 위해 & 0xFF 적용
                    for (let i = 0; i < bytes.length; ++i) {
                        binaryString += String.fromCharCode(bytes[i] & 0xFF);
                    }
                    setValue(binaryString);
                }
            }
        }
        
        // 파일 선택 함수
        function handleFileSelect(setValue) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '*/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    if (file.type.startsWith('text/')) {
                        const text = await file.text();
                        setValue(text);
                    } else {
                        // 바이너리 파일: 바이너리 문자열 로딩 (개선된 방식)
                        const arrayBuffer = await file.arrayBuffer();
                        const bytes = new Uint8Array(arrayBuffer);
                        let binaryString = '';
                        // 바이트 값을 정확히 보존하기 위해 & 0xFF 적용
                        for (let i = 0; i < bytes.length; ++i) {
                            binaryString += String.fromCharCode(bytes[i] & 0xFF);
                        }
                        setValue(binaryString);
                    }
                }
            };
            input.click();
        }
        
        // 이미지 판별 및 Data URL 생성
        function sniffImage(binaryStr) {
            if (!binaryStr) return null;
            if (binaryStr.startsWith('\x89PNG\r\n\x1a\n')) return { mime: 'image/png', ext: 'png' };
            if (binaryStr.startsWith('\xFF\xD8')) return { mime: 'image/jpeg', ext: 'jpg' };
            if (binaryStr.startsWith('GIF87a') || binaryStr.startsWith('GIF89a')) return { mime: 'image/gif', ext: 'gif' };
            if (binaryStr.startsWith('BM')) return { mime: 'image/bmp', ext: 'bmp' };
            if (binaryStr.trim().startsWith('<svg')) return { mime: 'image/svg+xml', ext: 'svg' };
            return null;
        }

        // CBOR 디코딩 함수 (cborg 라이브러리 사용)
        function decodeCBOR(binaryStr) {
            console.log("decodeCBOR: 진입, 데이터 길이:", binaryStr ? binaryStr.length : 0);
            
            try {
                if (!binaryStr) {
                    console.log("decodeCBOR: 데이터가 없음");
                    return null;
                }
                
                // cborg 라이브러리 사용 - 다양한 방식으로 접근 시도
                let cborgLib = null;
                
                if (typeof window !== 'undefined') {
                    cborgLib = window.cborg || window.CBOR || window.cbor;
                }
                
                if (!cborgLib && typeof cborg !== 'undefined') {
                    cborgLib = cborg;
                }
                
                if (!cborgLib && typeof CBOR !== 'undefined') {
                    cborgLib = CBOR;
                }
                
                if (!cborgLib) {
                    console.error("decodeCBOR: cborg 라이브러리를 찾을 수 없음");
                    return "CBOR 라이브러리가 로드되지 않았습니다. 페이지를 새로고침해보세요.";
                }
                
                console.log("decodeCBOR: cborg 라이브러리 사용");
                const bytes = binStringToUint8(binaryStr);
                console.log("decodeCBOR: 바이트 변환 완료, 길이:", bytes.length);
                console.log("decodeCBOR: 첫 10바이트:", Array.from(bytes.slice(0, 10)));
                
                const decoded = cborgLib.decode(bytes, { useMaps: false });
                console.log("decodeCBOR: cborg 디코딩 성공:", decoded);
                
                return JSON.stringify(decoded, null, 2);
                
            } catch (error) {
                console.error("decodeCBOR: 디코딩 실패:", error.message);
                return `CBOR 디코딩 오류: ${error.message}`;
            }
        }

        // CBOR 인코딩 함수
        function encodeCBOR(data) {
            const result = [];
            
            function writeUint(value, length) {
                const bytes = [];
                for (let i = length - 1; i >= 0; i--) {
                    bytes.push((value >> (i * 8)) & 0xFF);
                }
                return bytes;
            }
            
            function encodeLength(majorType, length) {
                if (length < 24) {
                    return [(majorType << 5) | length];
                } else if (length < 256) {
                    return [(majorType << 5) | 24, length];
                } else if (length < 65536) {
                    return [(majorType << 5) | 25, ...writeUint(length, 2)];
                } else if (length < 4294967296) {
                    return [(majorType << 5) | 26, ...writeUint(length, 4)];
                } else {
                    return [(majorType << 5) | 27, ...writeUint(length, 8)];
                }
            }
            
            function encodeValue(value) {
                if (typeof value === 'number') {
                    if (Number.isInteger(value)) {
                        if (value >= 0) {
                            // Positive integer (major type 0)
                            return encodeLength(0, value);
                        } else {
                            // Negative integer (major type 1)
                            return encodeLength(1, -1 - value);
                        }
                    } else {
                        // Float (major type 7)
                        // For simplicity, encode as 64-bit float
                        const buffer = new ArrayBuffer(8);
                        const view = new DataView(buffer);
                        view.setFloat64(0, value, false); // big-endian
                        return [0xFB, ...Array.from(new Uint8Array(buffer))];
                    }
                } else if (typeof value === 'string') {
                    // 바이너리 데이터인지 확인 (JPG 등 이미지 파일 감지)
                    if (isBinaryString(value, 0.1) || sniffImage(value)) {
                        // 바이너리 데이터는 byte string (major type 2)으로 인코딩
                        const binaryBytes = new Uint8Array(value.length);
                        for (let i = 0; i < value.length; i++) {
                            binaryBytes[i] = value.charCodeAt(i) & 0xFF;
                        }
                        return [...encodeLength(2, binaryBytes.length), ...Array.from(binaryBytes)];
                    } else {
                        // 일반 텍스트는 text string (major type 3)으로 인코딩
                        const utf8Bytes = new TextEncoder().encode(value);
                        return [...encodeLength(3, utf8Bytes.length), ...Array.from(utf8Bytes)];
                    }
                } else if (typeof value === 'boolean') {
                    // Simple value (major type 7)
                    return [value ? 0xF5 : 0xF4]; // true : false
                } else if (value === null) {
                    // Null (major type 7)
                    return [0xF6];
                } else if (value === undefined) {
                    // Undefined (major type 7)
                    return [0xF7];
                } else if (Array.isArray(value)) {
                    // Array (major type 4)
                    const arrayBytes = [...encodeLength(4, value.length)];
                    for (const item of value) {
                        arrayBytes.push(...encodeValue(item));
                    }
                    return arrayBytes;
                } else if (typeof value === 'object' && value !== null) {
                    // Map (major type 5)
                    const keys = Object.keys(value);
                    const mapBytes = [...encodeLength(5, keys.length)];
                    for (const key of keys) {
                        mapBytes.push(...encodeValue(key));
                        mapBytes.push(...encodeValue(value[key]));
                    }
                    return mapBytes;
                } else {
                    throw new Error(`Unsupported data type: ${typeof value}`);
                }
            }
            
            return new Uint8Array(encodeValue(data));
        }

        // CBOR 데이터인지 확인하는 함수 (개선된 버전)
        function isCBORData(binaryStr) {
            console.log("isCBORData: 진입. 데이터 길이:", binaryStr ? binaryStr.length : 0);
            
            if (!binaryStr || binaryStr.length === 0) {
                console.log("isCBORData: 데이터가 없어 false 반환");
                return false;
            }
            
            // 1. CBOR 구조적 특성 검사 (라이브러리 없이도 기본 감지 가능)
            const bytes = Array.from(binaryStr).map(c => c.charCodeAt(0));
            console.log("isCBORData: 바이트 배열 처음 10개:", bytes.slice(0, 10));
            
            if (bytes.length === 0) return false;
            
            // CBOR의 첫 바이트에서 Major Type 추출
            const firstByte = bytes[0];
            const majorType = (firstByte >> 5) & 0x07; // 상위 3비트
            const additionalInfo = firstByte & 0x1F;   // 하위 5비트
            
            console.log("isCBORData: 첫 바이트:", firstByte.toString(16), "Major Type:", majorType, "Additional Info:", additionalInfo);
            
            // 유효한 CBOR Major Type인지 확인 (0-7)
            if (majorType > 7) {
                console.log("isCBORData: 유효하지 않은 Major Type");
                return false;
            }
            
            // 기본적인 CBOR 구조 검증
            try {
                if (!isValidCBORStructure(bytes)) {
                    console.log("isCBORData: CBOR 구조 검증 실패");
                    return false;
                }
            } catch (e) {
                console.log("isCBORData: CBOR 구조 검증 중 오류:", e.message);
                return false;
            }
            
            // 2. cborg 라이브러리로 정확한 검증 (가능한 경우)
            try {
                // cborg 라이브러리 확인 - 다양한 방식으로 접근 시도
                let cborgLib = null;
                
                if (typeof window !== 'undefined') {
                    cborgLib = window.cborg || window.CBOR || window.cbor;
                }
                
                if (!cborgLib && typeof cborg !== 'undefined') {
                    cborgLib = cborg;
                }
                
                if (!cborgLib && typeof CBOR !== 'undefined') {
                    cborgLib = CBOR;
                }
                
                if (!cborgLib) {
                    console.log("isCBORData: cborg 라이브러리가 없지만 구조적 검증 통과로 true 반환");
                    return true; // 구조적 검증만으로도 충분히 신뢰할 수 있음
                }
                
                // 바이너리 문자열을 Uint8Array로 변환
                const uint8Bytes = binStringToUint8(binaryStr);
                console.log("isCBORData: Uint8Array로 변환된 바이트:", uint8Bytes.slice(0, 10));

                // cborg 라이브러리로 직접 디코딩 시도
                const decoded = cborgLib.decode(uint8Bytes);
                
                console.log("isCBORData: cborg.decode 성공. 디코딩 결과:", decoded);
                return true;
            } catch (e) {
                console.log("isCBORData: cborg.decode 실패하지만 구조적 검증은 통과. 오류:", e.message);
                // 라이브러리 디코딩이 실패해도 구조적 검증을 통과했다면 CBOR일 가능성 높음
                return true;
            }
        }
        
        // CBOR 구조 검증 헬퍼 함수
        function isValidCBORStructure(bytes) {
            let position = 0;
            
            function readCBORItem() {
                if (position >= bytes.length) return false;
                
                const firstByte = bytes[position++];
                const majorType = (firstByte >> 5) & 0x07;
                const additionalInfo = firstByte & 0x1F;
                
                console.log("CBOR 구조 검증: position", position-1, "Major Type:", majorType, "Additional Info:", additionalInfo);
                
                // Additional Info가 24-27인 경우 추가 바이트 필요
                let length = additionalInfo;
                if (additionalInfo === 24) {
                    if (position >= bytes.length) return false;
                    length = bytes[position++];
                } else if (additionalInfo === 25) {
                    if (position + 1 >= bytes.length) return false;
                    length = (bytes[position] << 8) | bytes[position + 1];
                    position += 2;
                } else if (additionalInfo === 26) {
                    if (position + 3 >= bytes.length) return false;
                    length = (bytes[position] << 24) | (bytes[position + 1] << 16) | 
                             (bytes[position + 2] << 8) | bytes[position + 3];
                    position += 4;
                } else if (additionalInfo === 27) {
                    // 8바이트 길이는 현재 지원하지 않음
                    return false;
                } else if (additionalInfo > 27) {
                    return false;
                }
                
                // Major Type별 처리
                switch (majorType) {
                    case 0: // unsigned integer
                    case 1: // negative integer
                    case 7: // float, simple values
                        // 이미 처리됨
                        break;
                    case 2: // byte string
                    case 3: // text string
                        // 지정된 길이만큼 바이트 건너뛰기
                        position += length;
                        if (position > bytes.length) return false;
                        break;
                    case 4: // array
                        // 배열의 각 요소 검증
                        for (let i = 0; i < length; i++) {
                            if (!readCBORItem()) return false;
                        }
                        break;
                    case 5: // map
                        // 맵의 각 키-값 쌍 검증
                        for (let i = 0; i < length; i++) {
                            if (!readCBORItem()) return false; // 키
                            if (!readCBORItem()) return false; // 값
                        }
                        break;
                    case 6: // semantic tag
                        // 태그 다음에 오는 값 검증
                        if (!readCBORItem()) return false;
                        break;
                    default:
                        return false;
                }
                
                return true;
            }
            
            // 전체 구조 검증
            const result = readCBORItem();
            console.log("CBOR 구조 검증 결과:", result, "최종 position:", position, "전체 길이:", bytes.length);
            
            // 모든 바이트가 소비되어야 완전한 CBOR
            return result && position === bytes.length;
        }

        // Beautify & syntax highlight helpers (JSON/XML)
        function formatXml(xml) {
            let formatted = '';
            const reg = /(>)(<)(\/*)/g;
            xml = xml.replace(reg, '$1\r\n$2$3');
            let pad = 0;
            xml.split('\r\n').forEach((node) => {
                let indent = 0;
                if (node.match(/.+<\/\w[^>]*>$/)) {
                    indent = 0;
                } else if (node.match(/^<\/\w/)) {
                    if (pad !== 0) pad -= 1;
                } else if (node.match(/^<\w([^>]*[^/])?>.*$/)) {
                    indent = 1;
                } else {
                    indent = 0;
                }
                formatted += '  '.repeat(pad) + node + '\r\n';
                pad += indent;
            });
            return formatted.trim();
        }
        function validateXml(xmlStr) {
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(xmlStr, "application/xml");
                const parsererror = doc.getElementsByTagName("parsererror");
                if (parsererror.length > 0) {
                    const msg = parsererror[0].textContent;
                    const match = msg.match(/at line (\d+)/i);
                    return {
                        valid: false,
                        error: msg,
                        errorLine: match ? parseInt(match[1], 10) : null
                    };
                }
                return { valid: true };
            } catch (e) {
                return { valid: false, error: e.message, errorLine: null };
            }
        }
        function syntaxHighlightJson(json) {
            if (typeof json != 'string') {
                json = JSON.stringify(json, undefined, 2);
            }
            json = json
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
                let cls = 'json-number';
                if (/^"/.test(match)) {
                    if (/:$/.test(match)) {
                        cls = 'json-key';
                    } else {
                        cls = 'json-string';
                    }
                } else if (/true|false/.test(match)) {
                    cls = 'json-boolean';
                } else if (/null/.test(match)) {
                    cls = 'json-null';
                }
                return '<span class="' + cls + '">' + match + '</span>';
            });
        }
        function syntaxHighlightXml(xml) {
            xml = xml
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            xml = xml.replace(/(&lt;\/?)([\w\-\.]+)(.*?)(\/?&gt;)/g, function (match, p1, p2, p3, p4) {
                return p1 + '<span class="xml-tag">' + p2 + '</span>' + p3 + p4;
            });
            xml = xml.replace(/([\w\-\.]+)="([^"]*)"/g, function (match, p1, p2) {
                return '<span class="xml-attr">' + p1 + '</span>="<span class="xml-attr-value">' + p2 + '</span>"';
            });
            return xml;
        }

        // -------------------------
        // Codec 전략 (객체지향 구조)
        // -------------------------
        const Codecs = (() => {
            // 바이너리 포맷 감지 함수
            function detectBinaryFormat(binaryStr) {
                if (!binaryStr || binaryStr.length < 4) return null;
                
                const bytes = Array.from(binaryStr).map(c => c.charCodeAt(0));
                
                // 이미지 포맷 감지
                if (bytes[0] === 0xFF && bytes[1] === 0xD8 && bytes[2] === 0xFF) {
                    return 'JPEG';
                }
                if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4E && bytes[3] === 0x47) {
                    return 'PNG';
                }
                if (bytes[0] === 0x47 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x38) {
                    return 'GIF';
                }
                if ((bytes[0] === 0x52 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x46) ||
                    (bytes[8] === 0x57 && bytes[9] === 0x45 && bytes[10] === 0x42 && bytes[11] === 0x50)) {
                    return 'WebP';
                }
                if (bytes[0] === 0x42 && bytes[1] === 0x4D) {
                    return 'BMP';
                }
                
                // 아카이브 포맷
                if (bytes[0] === 0x50 && bytes[1] === 0x4B && bytes[2] === 0x03 && bytes[3] === 0x04) {
                    return 'ZIP';
                }
                if (bytes[0] === 0x1F && bytes[1] === 0x8B) {
                    return 'GZIP';
                }
                if (bytes[0] === 0x75 && bytes[1] === 0x73 && bytes[2] === 0x74 && bytes[3] === 0x61) {
                    return 'TAR';
                }
                
                // PDF
                if (bytes[0] === 0x25 && bytes[1] === 0x50 && bytes[2] === 0x44 && bytes[3] === 0x46) {
                    return 'PDF';
                }
                
                // 실행 파일
                if (bytes[0] === 0x4D && bytes[1] === 0x5A) {
                    return 'EXE';
                }
                if (bytes[0] === 0x7F && bytes[1] === 0x45 && bytes[2] === 0x4C && bytes[3] === 0x46) {
                    return 'ELF';
                }
                
                // 기타 바이너리 포맷
                if (bytes[0] === 0x00 && bytes[1] === 0x00 && bytes[2] === 0x01 && bytes[3] === 0x00) {
                    return 'ICO';
                }
                
                return null;
            }

            // 공통 finalize
            function finalize(decoded, encoding, input, forceBinary = false) {
                const res = { decoded, encoding, error: null, isBinary: false, matched: true };
                res.isBinary = forceBinary || isBinaryString(res.decoded, 0.2);
                
                // 바이너리 데이터인 경우 포맷 감지 (CBOR는 제외)
                if (res.isBinary && !encoding.includes('CBOR')) {
                    const binaryFormat = detectBinaryFormat(res.decoded);
                    if (binaryFormat) {
                        res.encoding = `${encoding}-${binaryFormat}`;
                    }
                }
                
                // 디코딩 불가 케이스(텍스트성 인코딩으로 판단되었지만 의미 없는 결과)
                if (
                    input &&
                    res.isBinary &&
                    (encoding === 'Plain Text' || encoding === 'Quoted-Printable' || encoding === 'HTML Entities' || encoding === 'Unicode Escape')
                ) {
                    return { decoded: '', encoding: '', error: '디코딩할 수 없는 데이터입니다.', isBinary: false, matched: true };
                }
                return res;
            }

            // CBOR codec
            const CBOR = {
                id: 'cbor',
                label: 'CBOR',
                description: "CBOR(Concise Binary Object Representation)은 JSON과 유사한 이진 직렬화 포맷입니다. 바이너리·Base64로 전달된 데이터를 구조화된 값으로 복원합니다.",
                detect(input) {
                    try {
                        if (typeof cborg === 'undefined') return { matched: false };
                        const s = input || '';
                        if (!s) return { matched: false };

                        // 시도 조건: 명백한 Base64이거나, 바이너리스러운 문자열일 때만
                        const looksBase64 = /^[A-Za-z0-9+/=\s]+$/.test(s) && s.replace(/\s/g, '').length % 4 === 0 && s.replace(/\s/g, '').length >= 8;
                        const looksBinary = isBinaryString(s, 0.05);

                        if (!looksBase64 && !looksBinary) return { matched: false };

                        // 바이트 준비
                        let bytes;
                        if (looksBase64) {
                            try {
                                bytes = base64ToUint8(s);
                            } catch {
                                return { matched: false };
                            }
                        } else {
                            bytes = binStringToUint8(s);
                        }

                        // 디코드 시도
                        const value = cborg.decode(bytes);

                        // 결과를 문자열로 변환
                        let out;
                        if (typeof value === 'string') {
                            out = value;
                        } else if (value instanceof Uint8Array) {
                            // 원시 바이트: 바이너리 문자열로 전달하여 HEX 뷰 제공
                            out = uint8ToBinString(value);
                        } else {
                            try {
                                out = JSON.stringify(value);
                            } catch {
                                out = String(value);
                            }
                        }
                        return finalize(out, this.label, input);
                    } catch {
                        return { matched: false };
                    }
                },
                encode(input) {
                    // 자체 CBOR 인코딩 함수 사용
                    try {
                        let data;
                        // JSON 문자열인지 확인하고 파싱 시도
                        try {
                            data = JSON.parse(input);
                        } catch {
                            // JSON이 아니면 문자열로 처리
                            data = input;
                        }
                        
                        const bytes = encodeCBOR(data);
                        
                        // Binary 형태로 반환
                        return Array.from(bytes).map(b => String.fromCharCode(b)).join('');
                    } catch (e) {
                        return '';
                    }
                }
            };

            const Hex = {
                id: 'hex',
                label: 'Hex',
                description: "Hex(16진수) 인코딩은 각 바이트를 두 자리 16진수 문자열로 변환합니다. 예: 0x41 → '41'",
                detect(input) {
                    try {
                        const compact = (input || '').replace(/\s/g, '');
                        if (/^(0x)?([0-9a-fA-F]{2})+$/.test(compact)) {
                            const hex = compact.replace(/^0x/, '');
                            // 바이트 배열로 변환
                            const bytes = new Uint8Array(hex.length / 2);
                            for (let i = 0; i < hex.length; i += 2) {
                                bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
                            }
                            
                            // 먼저 바이너리 문자열 생성 (CBOR 등 바이너리 데이터용)
                            let binaryStr = '';
                            for (let i = 0; i < bytes.length; i++) {
                                binaryStr += String.fromCharCode(bytes[i]);
                            }
                            
                            // UTF-8 텍스트로 해석 가능한지 확인
                            try {
                                const str = new TextDecoder('utf-8', { fatal: true }).decode(bytes);
                                // UTF-8로 성공적으로 디코딩되고, 제어 문자가 많지 않으면 텍스트로 처리
                                const controlChars = str.match(/[\x00-\x1F\x7F-\x9F]/g);
                                if (!controlChars || controlChars.length < str.length * 0.3) {
                                    return finalize(str, this.label, input);
                                }
                            } catch {
                                // UTF-8 디코딩 실패 - 바이너리로 처리
                            }
                            
                            // 바이너리 데이터로 처리
                            return finalize(binaryStr, this.label, input, true); // isBinary = true
                        }
                    } catch {}
                    return { matched: false };
                },
                encode(input) {
                    // UTF-8 바이트로 변환 후 Hex 인코딩
                    try {
                        const utf8Bytes = new TextEncoder().encode(input);
                        return Array.from(utf8Bytes).map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase();
                    } catch {
                        // Fallback: 문자 코드 직접 변환
                        return Array.from(input).map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join('').toUpperCase();
                    }
                }
            };

            const Base64 = {
                id: 'base64',
                label: 'Base64',
                description: "Base64는 바이너리 데이터를 텍스트로 안전하게 변환하는 인코딩 방식입니다. 이메일 첨부, 이미지 데이터 등에서 널리 사용됩니다.",
                detect(input) {
                    try {
                        if (
                            /^[A-Za-z0-9+/=\s]+$/.test(input || '') &&
                            (input || '').length >= 8 &&
                            (input || '').replace(/\s/g, '').length % 4 === 0
                        ) {
                            const base64Clean = (input || '').replace(/\s/g, '');
                            // Base64를 바이트 배열로 디코딩
                            const binaryString = atob(base64Clean);
                            const bytes = new Uint8Array(binaryString.length);
                            for (let i = 0; i < binaryString.length; i++) {
                                bytes[i] = binaryString.charCodeAt(i);
                            }
                            // UTF-8로 디코딩 시도
                            try {
                                const str = new TextDecoder('utf-8').decode(bytes);
                                return finalize(str, this.label, input);
                            } catch {
                                // UTF-8 디코딩 실패시 바이너리 문자열로 처리
                                return finalize(binaryString, this.label, input);
                            }
                        }
                    } catch {}
                    return { matched: false };
                },
                encode(input) {
                    try {
                        // UTF-8 바이트로 변환 후 Base64 인코딩
                        const utf8Bytes = new TextEncoder().encode(input);
                        const binaryString = Array.from(utf8Bytes).map(b => String.fromCharCode(b)).join('');
                        return btoa(binaryString);
                    } catch {
                        // Fallback
                        return btoa(unescape(encodeURIComponent(input)));
                    }
                }
            };

            const Base64URL = {
                id: 'base64url',
                label: 'Base64URL',
                description: "Base64URL은 '+','/'를 '-','_'로 바꾸고 '=' 패딩을 제거한 변형입니다. JWT 등에서 사용.",
                detect(input) {
                    try {
                        const s = input || '';
                        if (/^[A-Za-z0-9_\-=]+$/.test(s) && s.length >= 8 && (s.includes('-') || s.includes('_'))) {
                            let b64 = s.replace(/-/g, '+').replace(/_/g, '/');
                            while (b64.length % 4 !== 0) b64 += '=';
                            const out = atob(b64);
                            return finalize(out, this.label, input);
                        }
                    } catch {}
                    return { matched: false };
                },
                encode(input) {
                    try {
                        let b64 = btoa(input);
                        return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
                    } catch {
                        let b64 = btoa(unescape(encodeURIComponent(input)));
                        return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
                    }
                }
            };

            const UrlEncoding = {
                id: 'url',
                label: 'URL Encoding',
                description: "URL Encoding은 안전하지 않은 문자를 %XX로 변환합니다. 예: 공백 → %20",
                detect(input) {
                    try {
                        const s = input || '';
                        if (/%[0-9A-Fa-f]{2}/.test(s)) {
                            const out = decodeURIComponent(s);
                            return finalize(out, this.label, input);
                        }
                    } catch {}
                    return { matched: false };
                },
                encode(input) {
                    return encodeURIComponent(input);
                }
            };

            const HtmlEntities = {
                id: 'html',
                label: 'HTML Entities',
                description: "HTML Entities는 특수문자를 &#코드; 또는 &이름; 형태로 변환합니다. 예: < → &lt;",
                detect(input) {
                    try {
                        const s = input || '';
                        if (/&[a-zA-Z]+;/.test(s)) {
                            const txt = document.createElement('textarea');
                            txt.innerHTML = s;
                            return finalize(txt.value, this.label, input);
                        }
                    } catch {}
                    return { matched: false };
                },
                encode(input) {
                    return input.replace(/[\u00A0-\u9999<>&"']/gim, i => '&#' + i.charCodeAt(0) + ';');
                }
            };

            const UnicodeEsc = {
                id: 'unicode',
                label: 'Unicode Escape (\\uXXXX)',
                description: "유니코드 이스케이프는 각 문자를 \\uXXXX로 변환합니다. 예: 가 → \\uAC00",
                detect(input) {
                    try {
                        const s = input || '';
                        if (/\\u[0-9a-fA-F]{4}/.test(s)) {
                            const out = s.replace(/\\u([0-9a-fA-F]{4})/g, (m, g1) => String.fromCharCode(parseInt(g1, 16)));
                            return finalize(out, this.label, input);
                        }
                    } catch {}
                    return { matched: false };
                },
                encode(input) {
                    return input.replace(/[\s\S]/g, c => '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4));
                }
            };

            const QuotedPrintable = {
                id: 'qp',
                label: 'Quoted-Printable',
                description: "Quoted-Printable은 8비트를 7비트 전송에 맞추는 인코딩입니다. 예: =0D=0A",
                detect(input) {
                    try {
                        const s = input || '';
                        const matches = s.match(/=([0-9A-Fa-f]{2})/g);
                        if (matches && matches.length > 0 && matches.length * 3 > s.length * 0.3) {
                            let out = s.replace(/=(\r?\n|\r)/g, '').replace(/=([0-9A-Fa-f]{2})/g, (m, g1) =>
                                String.fromCharCode(parseInt(g1, 16))
                            );
                            return finalize(out, this.label, input);
                        }
                    } catch {}
                    return { matched: false };
                },
                encode(input) {
                    return input.replace(/[\x00-\x1F\x7F-\xFF=]/g, c => '=' + c.charCodeAt(0).toString(16).toUpperCase().padStart(2, '0'));
                }
            };

            const Binary = {
                id: 'bin',
                label: 'Binary',
                description: "바이너리(비가시 제어문자 포함) 데이터입니다.",
                detect(input) {
                    const s = input || '';
                    // 민감도 높임: 5%
                    if (isBinaryString(s, 0.05)) {
                        return { decoded: s, encoding: this.label, error: null, isBinary: true, matched: true };
                    }
                    return { matched: false };
                }
                // encode 없음 (노출 X)
            };

            const registry = [
                // CBOR을 먼저 시도해 Base64로 포장된 CBOR까지 처리
                CBOR,
                Hex,
                Base64,
                Base64URL,
                Binary,
                UrlEncoding,
                HtmlEntities,
                UnicodeEsc,
                QuotedPrintable
            ];

            function detect(input) {
                for (const codec of registry) {
                    const r = codec.detect && codec.detect(input);
                    if (r && r.matched) return r;
                }
                
                // Plain Text fallback 전에 CBOR 가능성 체크
                if (input && input.length > 0) {
                    if (isCBORData(input)) {
                        // CBOR로 인식된 경우 바이너리로 처리
                        return finalize(input, 'CBOR', input, true); // isBinary = true
                    }
                }
                
                // Fallback
                return finalize(input, 'Plain Text', input);
            }

            function getEncoderLabels() {
                return registry.filter(c => typeof c.encode === 'function').map(c => c.label);
            }
            function getEncoderByLabel(label) {
                return registry.find(c => c.label === label && typeof c.encode === 'function');
            }
            function getDescriptionByLabel(label) {
                const c = registry.find(c => c.label === label);
                return (c && c.description) || '';
            }

            return { detect, getEncoderLabels, getEncoderByLabel, getDescriptionByLabel };
        })();
        // -------------------------

        // 디코딩 감지 함수 (리팩토링: 전략 사용)
        function detectAndDecode(input) {
            return Codecs.detect(input);
        }

        // 인코딩 함수 (리팩토링: 전략 사용)
        function encodeText(input, encodingLabel) {
            const encoder = Codecs.getEncoderByLabel(encodingLabel) || Codecs.getEncoderByLabel('Base64');
            try {
                return encoder ? encoder.encode(input) : input;
            } catch {
                return '';
            }
        }

        function renderBeautifiedWithError(beautified, syntaxType, syntaxErrorLine) {
            if (!beautified) return null;
            const lines = beautified.split('\n');
            return (
                React.createElement('pre', {
                    style: {
                        background: '#23272e',
                        color: '#fff',
                        borderRadius: 6,
                        padding: 16,
                        fontSize: 15,
                        overflowX: 'auto',
                        marginBottom: 0,
                        marginTop: 0
                    }
                },
                    lines.map((line, idx) => {
                        let style = {};
                        if (syntaxErrorLine && idx + 1 === syntaxErrorLine) {
                            style = { background: '#ffebee', color: '#c62828' };
                        }
                        let html = line;
                        if (syntaxType === 'json') {
                            html = syntaxHighlightJson(line);
                        } else if (syntaxType === 'xml') {
                            html = syntaxHighlightXml(line);
                        }
                        return React.createElement('div', {
                            key: idx,
                            style: { ...style, whiteSpace: 'pre' },
                            dangerouslySetInnerHTML: { __html: html }
                        });
                    })
                )
            );
        }

        // -------------------------
        // 다국어 지원 시스템
        // -------------------------
        
        // 언어 감지 및 기본 언어 설정 (localStorage 우선)
        function detectBrowserLanguage() {
            // localStorage에서 저장된 언어 설정 확인
            const savedLanguage = localStorage.getItem('decodeall-language');
            if (savedLanguage && (savedLanguage === 'ko' || savedLanguage === 'en')) {
                return savedLanguage;
            }
            
            // 저장된 설정이 없으면 브라우저 언어 감지
            const lang = navigator.language || navigator.userLanguage;
            if (lang.startsWith('ko')) return 'ko';
            return 'en'; // 기본값은 영어
        }

        // 번역 데이터
        const translations = {
            ko: {
                // 메인 타이틀
                title: "자동 인코딩 감지 & 디코더",
                
                // 탭 제목
                tabDecoder: "디코더",
                tabEncoder: "인코더",
                
                // 디코더 섹션
                inputLabel: "디코딩할 텍스트 입력",
                inputPlaceholder: "직접 입력 | 드래그 앤 드롭 | 파일 로드 버튼으로 텍스트를 입력하세요...",
                outputLabel: "디코딩 결과",
                encodingTypeLabel: "감지된 인코딩",
                beautifyLabel: "Beautify",
                hexViewLabel: "HEX View",
                imageViewLabel: "이미지 보기",
                
                // 인코더 섹션
                encodeInputLabel: "인코딩할 텍스트 입력",
                encodeInputPlaceholder: "직접 입력 | 드래그 앤 드롭 | 파일 로드 버튼으로 텍스트를 입력하세요...",
                encodeResultLabel: "인코딩 결과",
                algorithmDescription: "알고리즘 설명",
                
                // 버튼
                copyButton: "복사",
                downloadButton: "파일 저장",
                pasteButton: "붙여넣기",
                clearButton: "지우기",
                
                // 메시지
                copySuccess: "복사했습니다.",
                copyError: "복사에 실패했습니다.",
                binaryNotCopyable: "바이너리 데이터는 복사할 수 없습니다.",
                downloadSuccess: "파일을 저장했습니다.",
                downloadError: "파일 저장에 실패했습니다.",
                pasteSuccess: "붙여넣기 완료",
                pasteError: "붙여넣기에 실패했습니다.",
                clearSuccess: "내용을 지웠습니다.",
                imageSaveSuccess: "이미지를 저장했습니다.",
                
                // 기타
                dragDropHint: "드래그앤드롭한 파일 및 텍스트 모두 동일하게 로컬에서만 처리됩니다.",
                privacyNote: "입력값은 브라우저에서만 처리되며 저장되지 않습니다.",
                supportedEncodings: "지원 인코딩",
                decodeDescription: "자동 디코더가 입력된 텍스트의 인코딩 방식을 감지하여 원본 텍스트로 복원합니다.",
                encodeDescription: "다양한 알고리즘을 선택하여 텍스트를 원하는 방식으로 인코딩할 수 있습니다.",
                cannotDecode: "디코딩할 수 없는 데이터입니다.",
                noData: "디코딩할 데이터가 없습니다.",
                cborDecoded: "CBOR 디코딩 결과",
                cborDiagnosticNotation: "CBOR Diagnostic Notation",
                
                // 언어 선택
                languageLabel: "언어",
                korean: "한국어",
                english: "English"
            },
            en: {
                // 메인 타이틀
                title: "Auto Encoding Detection & Decoder",
                
                // 탭 제목
                tabDecoder: "Decoder",
                tabEncoder: "Encoder",
                
                // 디코더 섹션
                inputLabel: "Input text to decode",
                inputPlaceholder: "Direct input | Drag & drop | File load button - Enter your text...",
                outputLabel: "Decoding result",
                encodingTypeLabel: "Detected encoding",
                beautifyLabel: "Beautify",
                hexViewLabel: "HEX View",
                imageViewLabel: "Image View",
                
                // 인코더 섹션
                encodeInputLabel: "Input text to encode",
                encodeInputPlaceholder: "Direct input | Drag & drop | File load button - Enter your text...",
                encodeResultLabel: "Encoding result",
                algorithmDescription: "Algorithm description",
                
                // 버튼
                copyButton: "Copy",
                downloadButton: "Save File",
                pasteButton: "Paste",
                clearButton: "Clear",
                
                // 메시지
                copySuccess: "Copied to clipboard.",
                copyError: "Failed to copy.",
                binaryNotCopyable: "Binary data cannot be copied.",
                downloadSuccess: "File saved successfully.",
                downloadError: "Failed to save file.",
                pasteSuccess: "Paste completed",
                pasteError: "Failed to paste.",
                clearSuccess: "Content cleared.",
                imageSaveSuccess: "Image saved successfully.",
                
                // 기타
                dragDropHint: "Drag and drop files are also processed locally only.",
                privacyNote: "Input is processed only in browser and not stored.",
                supportedEncodings: "Supported Encodings",
                decodeDescription: "Auto decoder detects the encoding method of input text and restores it to original text.",
                encodeDescription: "You can select various algorithms to encode text in your desired format.",
                cannotDecode: "Cannot decode the data.",
                noData: "No data to decode.",
                cborDecoded: "CBOR Decoded Result",
                cborDiagnosticNotation: "CBOR Diagnostic Notation",
                
                // 언어 선택
                languageLabel: "Language",
                korean: "한국어",
                english: "English"
            }
        };

        function EncoderDecoderTabs() {
            // 언어 상태 (브라우저 언어 자동 감지)
            const [language, setLanguage] = useState(detectBrowserLanguage());
            
            // 번역 함수
            const t = (key) => translations[language][key] || key;
            
            const [tab, setTab] = useState(0);

            // 드래그오버 상태 추가
            const [isDragOverInput, setIsDragOverInput] = useState(false);
            const [isDragOverEncode, setIsDragOverEncode] = useState(false);

            // 디코딩 상태
            const [input, setInput] = useState('');
            const [output, setOutput] = useState('');
            const [encoding, setEncoding] = useState('');
            const [error, setError] = useState(null);
            
            // 데이터 포맷 상태
            const [dataFormat, setDataFormat] = useState(null); // 'text', 'json', 'xml', 'binary'
            const [binaryFormat, setBinaryFormat] = useState(null); // 'image', 'cbor', 'unknown'
            const [imageInfo, setImageInfo] = useState(null); // { src, mime, ext }
            const [cborDiagnostic, setCborDiagnostic] = useState(''); // CBOR 진단 표기 결과

            // 뷰티파이/구문 강조 상태
            const [beautified, setBeautified] = useState('');
            const [syntaxError, setSyntaxError] = useState(null);
            const [syntaxErrorLine, setSyntaxErrorLine] = useState(null);

            // 인코딩 상태
            const [encodeInput, setEncodeInput] = useState('');
            const [encodeType, setEncodeType] = useState('Base64');
            const [encodeResult, setEncodeResult] = useState('');
            const [encodeHexResult, setEncodeHexResult] = useState('');

            // 바이너리 여부 상태
            const [isBinaryOutput, setIsBinaryOutput] = useState(false);
            
            // CBOR 디코딩 상태
            const [cborOutput, setCborOutput] = useState('');
            const [isCborData, setIsCborData] = useState(false);
            const [isCborResultBinary, setIsCborResultBinary] = useState(false);

            const inputRef = useRef(null);
            const outputRef = useRef(null);
            const encodeInputRef = useRef(null);
            const paperRef = useRef(null);

            // Snackbar(토스트) 상태
            const [toast, setToast] = useState({ open: false, message: '', severity: 'success' });
            const showToast = (message, severity = 'success') => setToast({ open: true, message, severity });
            const handleToastClose = (event, reason) => {
                if (reason === 'clickaway') return;
                setToast(prev => ({ ...prev, open: false }));
            };

            useEffect(() => {
                gsap.from(paperRef.current, {
                    y: 60,
                    opacity: 0,
                    duration: 1,
                    ease: "power3.out"
                });
            }, []);

            // 언어 변경 시 HTML lang 속성 업데이트 및 localStorage 저장
            useEffect(() => {
                document.documentElement.lang = language;
                // 언어 설정을 localStorage에 저장
                localStorage.setItem('decodeall-language', language);
            }, [language]);

            // 1. 인코딩 감지 및 디코딩 함수
            const detectEncoding = (text) => {
                return Codecs.detect(text);
            };

            // 2. 디코딩된 데이터의 포맷 판별 함수
            const findDataFormat = (decodedData) => {
                if (!decodedData) return null;
                
                console.log("findDataFormat: 데이터 길이", decodedData.length);
                
                // 바이트 배열 생성
                const bytes = Array.from(decodedData).map(c => c.charCodeAt(0));
                console.log("findDataFormat: 첫 10바이트", bytes.slice(0, 10));
                
                // 1. 우선 CBOR 검사 (바이너리 판별 전에)
                if (bytes.length >= 1) {
                    console.log("findDataFormat: CBOR 검사 시작");
                    if (isCBORData(decodedData)) {
                        console.log("findDataFormat: CBOR로 판별됨");
                        return 'binary';
                    }
                }
                
                // 2. 이미지 포맷 검사
                if (bytes.length >= 2) {
                    if (sniffImage(decodedData)) {
                        console.log("findDataFormat: 이미지로 판별됨");
                        return 'binary';
                    }
                }
                
                // 3. 기타 알려진 바이너리 시그니처 검사
                if (bytes.length >= 4) {
                    if ((bytes[0] === 0xFF && bytes[1] === 0xD8) || // JPEG
                        (bytes[0] === 0x89 && bytes[1] === 0x50) || // PNG
                        (bytes[0] === 0x47 && bytes[1] === 0x49) || // GIF
                        (bytes[0] === 0x42 && bytes[1] === 0x4D) || // BMP
                        (bytes[0] === 0x50 && bytes[1] === 0x4B) || // ZIP
                        (bytes[0] === 0x1F && bytes[1] === 0x8B) || // GZIP
                        (bytes[0] === 0x25 && bytes[1] === 0x50) || // PDF
                        (bytes[0] === 0x4D && bytes[1] === 0x5A) || // EXE
                        (bytes[0] === 0x7F && bytes[1] === 0x45)) { // ELF
                        console.log("findDataFormat: 알려진 바이너리 시그니처로 판별됨");
                        return 'binary';
                    }
                }
                
                // 4. 바이너리 특성 체크 (통계적 접근)
                let controlChars = 0;
                let highBytes = 0;
                let nullBytes = 0;
                
                for (let i = 0; i < decodedData.length; i++) {
                    const code = decodedData.charCodeAt(i);
                    // 제어 문자 (탭, 개행, 캐리지 리턴 제외)
                    if ((code < 0x09 || (code > 0x0D && code < 0x20) || code === 0x7F)) {
                        controlChars++;
                    }
                    // 높은 바이트 값 (128 이상)
                    if (code >= 128) {
                        highBytes++;
                    }
                    // null 바이트
                    if (code === 0) {
                        nullBytes++;
                    }
                }
                
                const controlRatio = controlChars / decodedData.length;
                const highByteRatio = highBytes / decodedData.length;
                const nullRatio = nullBytes / decodedData.length;
                
                console.log("findDataFormat: controlRatio", controlRatio, "highByteRatio", highByteRatio, "nullRatio", nullRatio);
                
                // 바이너리 판별 조건 (null 바이트가 있거나 제어문자 비율이 높으면 바이너리)
                if (nullRatio > 0 || controlRatio > 0.02 || highByteRatio > 0.3) {
                    console.log("findDataFormat: 통계적 분석으로 바이너리 판별됨");
                    return 'binary';
                }
                
                // 5. JSON 파싱 시도
                try {
                    JSON.parse(decodedData);
                    console.log("findDataFormat: JSON으로 판별됨");
                    return 'json';
                } catch {}
                
                // 6. XML 체크
                if (/<[\w\s="'\/\-\.:]+>/.test(decodedData)) {
                    const xmlCheck = validateXml(decodedData);
                    if (xmlCheck.valid) {
                        console.log("findDataFormat: XML로 판별됨");
                        return 'xml';
                    }
                }
                
                console.log("findDataFormat: 텍스트로 판별됨");
                return 'text';
            };

            // 3. 바이너리 데이터의 세부 포맷 판별 함수
            const findBinaryFormat = (binaryData) => {
                console.log("findBinaryFormat: 진입");
                
                // 이미지 포맷 체크
                const imageResult = sniffImage(binaryData);
                if (imageResult) {
                    console.log("findBinaryFormat: 이미지로 판별됨:", imageResult.mime);
                    return { type: 'image', info: imageResult };
                }
                
                // CBOR 포맷 체크
                if (isCBORData(binaryData)) {
                    console.log("findBinaryFormat: CBOR 데이터로 판별됨");
                    
                    // CBOR 디코딩 시도하여 추가 정보 제공
                    try {
                        // cborg 라이브러리 확인 - 다양한 방식으로 접근 시도
                        let cborgLib = null;
                        
                        if (typeof window !== 'undefined') {
                            cborgLib = window.cborg || window.CBOR || window.cbor;
                        }
                        
                        if (!cborgLib && typeof cborg !== 'undefined') {
                            cborgLib = cborg;
                        }
                        
                        if (!cborgLib && typeof CBOR !== 'undefined') {
                            cborgLib = CBOR;
                        }
                        
                        if (cborgLib) {
                            const bytes = binStringToUint8(binaryData);
                            const decoded = cborgLib.decode(bytes, { useMaps: false });
                            console.log("findBinaryFormat: CBOR 디코딩 성공:", decoded);
                            return { 
                                type: 'cbor', 
                                decoded: decoded,
                                summary: typeof decoded === 'object' ? 
                                    (Array.isArray(decoded) ? `Array[${decoded.length}]` : `Object{${Object.keys(decoded).length}}`) :
                                    typeof decoded
                            };
                        } else {
                            console.log("findBinaryFormat: cborg 라이브러리 없음, 기본 CBOR 정보만 반환");
                            return { type: 'cbor' };
                        }
                    } catch (e) {
                        console.error("findBinaryFormat: CBOR 디코딩 실패:", e);
                        return { type: 'cbor', error: e.message };
                    }
                }
                
                console.log("findBinaryFormat: 알려진 포맷이 아닌 'unknown'으로 판별됨");
                return { type: 'unknown' };
            };

            // CBOR 데이터를 Diagnostic Notation으로 변환하는 함수
            const toCborDiagnostic = (cborBytes) => {
                console.log("toCborDiagnostic: 진입, 바이트 길이:", cborBytes ? cborBytes.length : 0);
                console.log("toCborDiagnostic: 입력 바이트:", cborBytes ? Array.from(cborBytes.slice(0, 20)) : []);
                
                try {
                    // cborg 라이브러리 확인 - 다양한 방식으로 접근 시도
                    let cborgLib = null;
                    
                    if (typeof window !== 'undefined') {
                        cborgLib = window.cborg || window.CBOR || window.cbor;
                    }
                    
                    if (!cborgLib && typeof cborg !== 'undefined') {
                        cborgLib = cborg;
                    }
                    
                    if (!cborgLib && typeof CBOR !== 'undefined') {
                        cborgLib = CBOR;
                    }
                    
                    if (!cborgLib) {
                        console.error("toCborDiagnostic: cborg 라이브러리를 찾을 수 없습니다");
                        return "CBOR 라이브러리를 찾을 수 없습니다. 페이지를 새로고침해보세요.";
                    }
                    
                    console.log("toCborDiagnostic: cborg 라이브러리 사용 가능");
                    
                    // CBOR 디코딩
                    const decoded = cborgLib.decode(cborBytes, { useMaps: false }); // Map 대신 일반 객체 사용
                    console.log("toCborDiagnostic: 디코딩 성공:", decoded);
                    
                    // 진단 표기법으로 포맷팅
                    function format(value, depth = 0) {
                        const indent = '  '.repeat(depth);
                        
                        if (typeof value === 'string') return `"${value}"`;
                        if (typeof value === 'number') return value.toString();
                        if (typeof value === 'boolean') return value.toString();
                        if (value === null) return 'null';
                        if (value === undefined) return 'undefined';
                        
                        if (value instanceof Uint8Array) {
                            const hex = Array.from(value).map(b => b.toString(16).padStart(2, '0')).join('');
                            return `h'${hex}'`;
                        }
                        
                        if (Array.isArray(value)) {
                            if (value.length === 0) return '[]';
                            if (depth > 3) return '[...]'; // 깊이 제한
                            const items = value.map(item => format(item, depth + 1));
                            if (items.join(', ').length < 80) {
                                return `[${items.join(', ')}]`;
                            } else {
                                return `[\n${indent}  ${items.join(',\n' + indent + '  ')}\n${indent}]`;
                            }
                        }
                        
                        if (value instanceof Map) {
                            if (value.size === 0) return '{}';
                            if (depth > 3) return '{...}'; // 깊이 제한
                            const entries = Array.from(value.entries()).map(([k, v]) => 
                                `${format(k, depth + 1)}: ${format(v, depth + 1)}`
                            );
                            if (entries.join(', ').length < 80) {
                                return `{${entries.join(', ')}}`;
                            } else {
                                return `{\n${indent}  ${entries.join(',\n' + indent + '  ')}\n${indent}}`;
                            }
                        }
                        
                        if (typeof value === 'object' && value !== null) {
                            const entries = Object.entries(value);
                            if (entries.length === 0) return '{}';
                            if (depth > 3) return '{...}'; // 깊이 제한
                            const formatted = entries.map(([k, v]) => 
                                `"${k}": ${format(v, depth + 1)}`
                            );
                            if (formatted.join(', ').length < 80) {
                                return `{${formatted.join(', ')}}`;
                            } else {
                                return `{\n${indent}  ${formatted.join(',\n' + indent + '  ')}\n${indent}}`;
                            }
                        }
                        
                        return String(value);
                    }
                    
                    const result = format(decoded);
                    console.log("toCborDiagnostic: 포맷팅 완료:", result);
                    return result;
                    
                } catch (e) {
                    console.error("toCborDiagnostic: 오류 발생:", e);
                    return `CBOR 디코딩 오류: ${e.message}`;
                }
            };

            // 디코딩 로직 파이프라인
            useEffect(() => {
                // --- 초기화 ---
                setOutput('');
                setEncoding('');
                setError(null);
                setDataFormat(null);
                setBinaryFormat(null);
                setImageInfo(null);
                setCborDiagnostic('');
                setBeautified('');
                setSyntaxError(null);
                setSyntaxErrorLine(null);

                if (input.length === 0) {
                    return;
                }

                // --- 1. 인코딩 감지 및 1차 디코딩 ---
                const decodedResult = detectEncoding(input);
                console.log("Pipeline Step 1: 인코딩 감지 결과:", decodedResult);

                if (!decodedResult || !decodedResult.matched || !decodedResult.decoded) {
                    setError(t('cannotDecode'));
                    setEncoding(decodedResult.encoding || '');
                    return;
                }
                
                setOutput(decodedResult.decoded);
                setEncoding(decodedResult.encoding);

                // --- 2. 데이터 포맷 판별 (JSON, XML, Binary, Text) ---
                const format = findDataFormat(decodedResult.decoded);
                setDataFormat(format);
                console.log("Pipeline Step 2: 데이터 포맷 판별 결과:", format);

                if (format === 'json' || format === 'xml') {
                    // --- 3a. JSON/XML 뷰티파이 ---
                    let beautifiedStr = '';
                    let syntaxErr = null;
                    let syntaxErrLine = null;

                    if (format === 'json') {
                        try {
                            const parsed = JSON.parse(decodedResult.decoded);
                            beautifiedStr = JSON.stringify(parsed, null, 2);
                        } catch (e) {
                            syntaxErr = e.message;
                            const match = e.message.match(/at position (\d+)/);
                            if (match) {
                                const pos = parseInt(match[1], 10);
                                syntaxErrLine = decodedResult.decoded.slice(0, pos).split('\n').length;
                            }
                        }
                    } else if (format === 'xml') {
                        beautifiedStr = formatXml(decodedResult.decoded);
                        const xmlCheck = validateXml(decodedResult.decoded);
                        if (!xmlCheck.valid) {
                            syntaxErr = xmlCheck.error;
                            syntaxErrLine = xmlCheck.errorLine;
                        }
                    }
                    setBeautified(beautifiedStr);
                    setSyntaxError(syntaxErr);
                    setSyntaxErrorLine(syntaxErrLine);

                } else if (format === 'binary') {
                    // --- 3b. 바이너리 포맷 판별 (Image, CBOR) ---
                    const binFormat = findBinaryFormat(decodedResult.decoded);
                    setBinaryFormat(binFormat.type);
                    console.log("Pipeline Step 3: 바이너리 포맷 판별 결과:", binFormat.type);

                    if (binFormat.type === 'image') {
                        const { mime, ext } = binFormat.info;
                        let src = '';
                        if (mime === 'image/svg+xml') {
                            src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(decodedResult.decoded)));
                        } else {
                            src = 'data:' + mime + ';base64,' + binaryStringToBase64(decodedResult.decoded);
                        }
                        setImageInfo({ src, mime, ext });
                        setEncoding(prev => `${prev}-${ext.toUpperCase()}`);

                    } else if (binFormat.type === 'cbor') {
                        const cborBytes = binStringToUint8(decodedResult.decoded);
                        const diagnostic = toCborDiagnostic(cborBytes);
                        setCborDiagnostic(diagnostic);
                        setEncoding(prev => `${prev}-CBOR`);
                    }
                }
            }, [input, language]);

            // 인코딩 입력 변화
            useEffect(() => {
                if (!encodeInput) {
                    setEncodeResult('');
                    setEncodeHexResult('');
                    return;
                }
                
                const result = encodeText(encodeInput, encodeType);
                setEncodeResult(result);
                
                // CBOR 인코딩인 경우 hex 결과도 생성
                if (encodeType === 'CBOR' && result) {
                    try {
                        // Binary 결과를 hex로 변환
                        const hexResult = Array.from(result)
                            .map(c => c.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase())
                            .join(' ');
                        setEncodeHexResult(hexResult);
                    } catch (e) {
                        setEncodeHexResult('');
                    }
                } else {
                    setEncodeHexResult('');
                }
            }, [encodeInput, encodeType]);

            // Chip 목록(선택 UI 완화)은 레지스트리에서 가져오기
            const encoderLabels = Codecs.getEncoderLabels();

            return (
                React.createElement(Grid, { container: true, spacing: 2, justifyContent: "center", alignItems: "center" },
                    React.createElement(Grid, { item: true, xs: 12, sm: 11, md: 8, lg: 6 },
                        React.createElement(Paper, { 
                            elevation: 3, 
                            style: { padding: '28px 20px' },
                            className: 'mobile-paper',
                            ref: paperRef 
                        },
                            React.createElement(Typography, { 
                                variant: "h4", 
                                component: "h1", 
                                gutterBottom: true, 
                                align: "center",
                                sx: {
                                    fontSize: { xs: '1.75rem', sm: '1.875rem', md: '2.125rem' },
                                    mb: { xs: 2, md: 3 },
                                    mt: { xs: 2, md: 0 }, // 모바일에서 상단 여백 조정
                                    lineHeight: { xs: 1.3, md: 1.2 },
                                    fontWeight: { xs: 600, md: 700 }
                                }
                            }, t('title')),
                            // 상단 보안/프라이버시 안내 강조 배너
                            React.createElement(MaterialUI.Alert, {
                                severity: "info",
                                variant: "outlined",
                                sx: {
                                    mb: { xs: 1.5, md: 2 },
                                    display: 'flex',
                                    alignItems: 'center',
                                    borderWidth: 1.5,
                                    borderColor: '#1976d2',
                                    color: '#1976d2',
                                    backgroundColor: 'transparent',
                                    borderRadius: 2,
                                    fontSize: { xs: '0.9rem', md: '1rem' },
                                    padding: { xs: '12px 16px', md: '16px' },
                                    '& .MuiTypography-body2': {
                                        fontSize: { xs: '0.9rem', md: '0.875rem' }
                                    },
                                    '& .MuiTypography-caption': {
                                        fontSize: { xs: '0.8rem', md: '0.75rem' }
                                    }
                                },
                                icon: React.createElement("span", { className: "material-icons", style: { color: '#1976d2' } }, "shield")
                            },
                                React.createElement(Box, { sx: { display: 'flex', flexDirection: 'column' } },
                                    React.createElement(Typography, { variant: "body2", sx: { fontWeight: 700 } }, t('privacyNote')),
                                    React.createElement(Typography, { variant: "caption" }, t('dragDropHint'))
                                )
                            ),
                            // 지원 인코딩 목록: 선택 UI 느낌을 제거한 배지(pill) 스타일
                            React.createElement(Box, { 
                                sx: { 
                                    display: 'flex', 
                                    flexWrap: 'wrap', 
                                    justifyContent: 'center', 
                                    mb: { xs: 1.5, md: 2 }, 
                                    gap: { xs: 0.5, md: 1 },
                                    px: { xs: 1, md: 0 }
                                } 
                            },
                                React.createElement(Box, {
                                    sx: {
                                        px: { xs: 1, md: 1.25 }, 
                                        py: { xs: 0.375, md: 0.5 }, 
                                        borderRadius: 9999,
                                        bgcolor: '#e3f2fd', 
                                        color: '#1976d2',
                                        fontSize: { xs: 10, md: 12 }, 
                                        fontWeight: 600
                                    }
                                }, t('supportedEncodings')),
                                [
                                    "CBOR",
                                    "Base64",
                                    "Base64URL",
                                    "URL Encoding",
                                    "Hex",
                                    "HTML Entities",
                                    "Unicode Escape (\\uXXXX)",
                                    "Quoted-Printable",
                                    "UTF-8 (bytes)",
                                    "EUC-KR (bytes)",
                                    "Plain Text"
                                ].map(label =>
                                    React.createElement(Box, {
                                        key: label,
                                        sx: {
                                            px: { xs: 0.75, md: 1.25 }, 
                                            py: { xs: 0.25, md: 0.5 }, 
                                            borderRadius: 9999,
                                            bgcolor: '#f5f7fa', 
                                            color: 'text.secondary',
                                            border: '1px solid #e0e0e0',
                                            fontSize: { xs: 9, md: 12 },
                                            cursor: 'default',
                                            pointerEvents: 'none'
                                        }
                                    }, label)
                                )
                            ),
                            React.createElement(Divider, { style: { margin: '10px 0 18px 0' } }),
                            React.createElement(Tabs, {
                                value: tab,
                                onChange: (e, v) => setTab(v),
                                centered: true,
                                sx: { 
                                    mb: 2,
                                    '& .MuiTab-root': {
                                        fontSize: { xs: '0.95rem', md: '0.875rem' },
                                        fontWeight: { xs: 600, md: 500 },
                                        minHeight: { xs: 48, md: 48 },
                                        padding: { xs: '12px 20px', md: '6px 12px' }
                                    }
                                }
                            },
                                React.createElement(Tab, { label: t('tabDecoder') }),
                                React.createElement(Tab, { label: t('tabEncoder') })
                            ),

                            // ----------------- 디코딩 탭 -----------------
                            tab === 0 && React.createElement(Box, null,
                                React.createElement(Typography, { variant: "body2", color: "textSecondary", align: "center", style: { marginBottom: 16 } },
                                    t('decodeDescription')
                                ),
                                // 입력 초기화 및 파일 로드 버튼
                                React.createElement(Box, { sx: { textAlign: 'right', mb: 1, display: 'flex', justifyContent: 'flex-end', gap: 1 } },
                                    React.createElement(
                                        MaterialUI.Button,
                                        {
                                            variant: "outlined",
                                            color: "primary",
                                            size: "small",
                                            startIcon: React.createElement("span", { className: "material-icons" }, "upload_file"),
                                            onClick: () => handleFileSelect(setInput)
                                        },
                                        "파일 로드"
                                    ),
                                    React.createElement(
                                        MaterialUI.Button,
                                        {
                                            variant: "outlined",
                                            color: "secondary",
                                            size: "small",
                                            startIcon: React.createElement("span", { className: "material-icons" }, "clear"),
                                            onClick: () => setInput(''),
                                            disabled: !input
                                        },
                                        "입력 초기화"
                                    )
                                ),
                                // 1. 디코딩 입력 (드래그앤드롭 지원 + 드래그오버 UI)
                                React.createElement(Box, {
                                    sx: { position: 'relative', mb: 3, borderRadius: 2 },
                                    onDrop: (e) => handleFileDrop(e, setInput).finally(() => setIsDragOverInput(false)),
                                    onDragOver: (e) => { e.preventDefault(); e.stopPropagation(); setIsDragOverInput(true); },
                                    onDragLeave: (e) => { e.preventDefault(); e.stopPropagation(); setIsDragOverInput(false); }
                                },
                                    React.createElement(TextField, {
                                        label: "인코딩된 텍스트 입력",
                                        variant: "outlined",
                                        fullWidth: true,
                                        multiline: true,
                                        rows: 12,
                                        value: input,
                                        onChange: e => setInput(e.target.value),
                                        placeholder: t('inputPlaceholder'),
                                        InputLabelProps: { shrink: true },
                                        inputRef: inputRef,
                                        inputProps: {
                                            onDrop: (e) => handleFileDrop(e, setInput).finally(() => setIsDragOverInput(false)),
                                            onDragOver: (e) => { e.preventDefault(); e.stopPropagation(); setIsDragOverInput(true); },
                                            onDragLeave: (e) => { e.preventDefault(); e.stopPropagation(); setIsDragOverInput(false); }
                                        },
                                        sx: {
                                            '& .MuiInputLabel-root': {
                                                fontSize: { xs: '1rem', md: '0.875rem' }
                                            },
                                            '& .MuiInputBase-input': {
                                                fontSize: { xs: '0.95rem', md: '0.875rem' },
                                                lineHeight: { xs: 1.4, md: 1.43 }
                                            },
                                            '& .MuiInputBase-root': {
                                                fontSize: { xs: '0.95rem', md: '0.875rem' }
                                            }
                                        },
                                        sx: {
                                            marginBottom: '20px',
                                            background: isDragOverInput ? "#e3f2fd" : "#fafdff",
                                            borderRadius: 2,
                                            transition: "background 0.2s"
                                        }
                                    }),
                                    isDragOverInput && React.createElement('div', {
                                        style: {
                                            pointerEvents: 'none',
                                            position: 'absolute',
                                            top: 0,
                                            left: 0,
                                            right: 0,
                                            bottom: 0,
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            borderRadius: 8,
                                            border: '2.5px dashed #1976d2',
                                            background: 'rgba(25, 118, 210, 0.10)',
                                            zIndex: 10,
                                            transition: "border 0.2s, background 0.2s",
                                            boxSizing: 'border-box'
                                        }
                                    },
                                        React.createElement('div', {
                                            style: {
                                                color: '#1976d2',
                                                fontWeight: 600,
                                                fontSize: 20,
                                                background: 'rgba(255,255,255,0.85)',
                                                borderRadius: 6,
                                                padding: '18px 36px',
                                                boxShadow: '0 2px 12px 0 rgba(25,118,210,0.08)',
                                                display: 'flex',
                                                alignItems: 'center',
                                                gap: 10
                                            }
                                        },
                                            React.createElement("span", { className: "material-icons", style: { fontSize: 28, marginRight: 8 } }, "file_upload"),
                                            "여기에 파일을 드롭하면 내용이 입력됩니다"
                                        )
                                    ),
                                    React.createElement('span', {
                                        style: {
                                            position: 'absolute',
                                            right: 16,
                                            bottom: 10,
                                            fontSize: 13,
                                            color: '#888',
                                            background: '#fafdff',
                                            padding: '0 6px'
                                        }
                                    }, `${bytesLen(input)} bytes`)
                                ),
                                React.createElement(Box, { sx: { mb: 2, textAlign: 'right' } },
                                    encoding && React.createElement(Chip, {
                                        label: `${t('encodingTypeLabel')}: ${encoding}`,
                                        color: encoding === 'Plain Text' ? 'default' : 'primary',
                                        variant: "outlined",
                                        sx: { 
                                            mr: 1,
                                            fontSize: { xs: '0.8125rem', md: '0.75rem' },
                                            height: { xs: 28, md: 24 },
                                            '& .MuiChip-label': {
                                                paddingLeft: { xs: 10, md: 8 },
                                                paddingRight: { xs: 10, md: 8 },
                                                fontSize: { xs: '0.8125rem', md: '0.75rem' }
                                            }
                                        }
                                    }),
                                    React.createElement(
                                        Tooltip,
                                        { title: isBinaryOutput ? "바이너리 데이터 복사" : "디코딩 결과 복사" },
                                        React.createElement(
                                            'span', // Add span wrapper
                                            { style: { display: 'inline-block' } },
                                            React.createElement(
                                                MaterialUI.Button,
                                                {
                                                    size: "small",
                                                    color: "primary",
                                                    variant: "outlined",
                                                    startIcon: React.createElement("span", { className: "material-icons" }, "content_copy"),
                                                    onClick: async () => {
                                                        if (!output) return;
                                                        
                                                        // 바이너리 데이터 검사
                                                        if (dataFormat === 'binary') {
                                                            showToast(t('binaryNotCopyable'), 'error');
                                                            return;
                                                        }
                                                        
                                                        try {
                                                            await navigator.clipboard.writeText(output);
                                                            showToast(t('copySuccess'), 'success');
                                                        } catch {
                                                            showToast(t('copyError'), 'error');
                                                        }
                                                    },
                                                    sx: { 
                                                        verticalAlign: 'middle', 
                                                        mr: 1,
                                                        fontSize: { xs: '0.875rem', md: '0.8125rem' },
                                                        padding: { xs: '8px 16px', md: '6px 12px' },
                                                        minHeight: { xs: 36, md: 32 }
                                                    },
                                                    disabled: !output
                                                },
                                                t('copyButton')
                                            )
                                        )
                                    ),
                                    React.createElement(
                                        Tooltip,
                                        { title: isBinaryOutput ? "바이너리 데이터를 파일로 저장" : "디코딩 결과를 파일로 저장" },
                                        React.createElement(
                                            'span', // Add span wrapper
                                            { style: { display: 'inline-block' } },
                                            React.createElement(
                                                MaterialUI.Button,
                                                {
                                                    size: "small",
                                                    color: "secondary",
                                                    variant: "outlined",
                                                    startIcon: React.createElement("span", { className: "material-icons" }, "download"),
                                                    onClick: () => {
                                                        if (!output) return;
                                                        try {
                                                            let content, filename;
                                                            if (dataFormat === 'binary') {
                                                                content = output; // 바이너리 데이터 자체 저장
                                                                filename = 'binary_result.bin';
                                                                // 바이너리 파일로 저장
                                                                const success = downloadBinaryFile(content, filename);
                                                                if (success) {
                                                                    showToast(t('downloadSuccess'), 'success');
                                                                } else {
                                                                    showToast(t('downloadError'), 'error');
                                                                }
                                                            } else {
                                                                // 다른 인코딩은 텍스트 파일로 저장
                                                                content = output;
                                                                const encodingType = encoding.toLowerCase().replace(/[^a-z0-9]/g, '_');
                                                                filename = `decoded_${encodingType}_result.txt`;
                                                                const success = downloadTextFile(content, filename);
                                                                if (success) {
                                                                    showToast(t('downloadSuccess'), 'success');
                                                                } else {
                                                                    showToast(t('downloadError'), 'error');
                                                                }
                                                            }
                                                        } catch (error) {
                                                            showToast(t('downloadError'), 'error');
                                                        }
                                                    },
                                                    sx: { 
                                                        verticalAlign: 'middle',
                                                        fontSize: { xs: '0.875rem', md: '0.8125rem' },
                                                        padding: { xs: '8px 16px', md: '6px 12px' },
                                                        minHeight: { xs: 36, md: 32 }
                                                    },
                                                    disabled: !output
                                                },
                                                t('downloadButton')
                                            )
                                        )
                                    )
                                ),
                                // 디코딩 결과 (원본)
                                React.createElement(Box, { sx: { position: 'relative' } },
                                    error === t('cannotDecode') ? (
                                        React.createElement('div', {
                                            style: {
                                                minHeight: 220,
                                                maxHeight: 320,
                                                background: '#fff3e0',
                                                color: '#c62828',
                                                borderRadius: 6,
                                                padding: 32,
                                                fontSize: 18,
                                                fontWeight: 500,
                                                display: 'flex',
                                                flexDirection: 'column',
                                                alignItems: 'center',
                                                justifyContent: 'center',
                                                marginBottom: '20px',
                                                border: '1.5px solid #ffc107'
                                            }
                                        },
                                            React.createElement('div', null, t('cannotDecode')),
                                            encoding && React.createElement('div', {
                                                style: {
                                                    marginTop: 18,
                                                    fontSize: 15,
                                                    color: '#1976d2',
                                                    fontWeight: 400,
                                                    background: '#e3f2fd',
                                                    borderRadius: 4,
                                                    padding: '6px 16px'
                                                }
                                            }, `입력 데이터 형식: ${encoding}`)
                                        )
                                    ) : (
                                        dataFormat === 'binary' && !imageInfo && binaryFormat !== 'cbor'
                                            ? React.createElement(TextField, {
                                                label: t('hexViewLabel'),
                                                variant: "outlined",
                                                fullWidth: true,
                                                multiline: true,
                                                rows: 12,
                                                value: toHexView(output),
                                                InputLabelProps: { shrink: true },
                                                inputRef: outputRef,
                                                style: { marginBottom: '20px', background: "#f0f0f0", fontFamily: 'Consolas, monospace' },
                                                InputProps: { 
                                                    readOnly: true,
                                                    style: { fontFamily: 'Consolas, monospace' }
                                                },
                                                sx: {
                                                    '& .MuiInputLabel-root': {
                                                        fontSize: { xs: '1rem', md: '0.875rem' }
                                                    },
                                                    '& .MuiInputBase-input': {
                                                        fontSize: { xs: '0.9rem', md: '0.8125rem' },
                                                        lineHeight: { xs: 1.4, md: 1.43 }
                                                    }
                                                }
                                            })
                                            : React.createElement(TextField, {
                                                label: t('outputLabel'),
                                                variant: "outlined",
                                                fullWidth: true,
                                                multiline: true,
                                                rows: 12,
                                                value: output,
                                                InputLabelProps: { shrink: true },
                                                inputRef: outputRef,
                                                style: { marginBottom: '20px', background: "#fafdff" },
                                                InputProps: { readOnly: true },
                                                sx: {
                                                    '& .MuiInputLabel-root': {
                                                        fontSize: { xs: '1rem', md: '0.875rem' }
                                                    },
                                                    '& .MuiInputBase-input': {
                                                        fontSize: { xs: '0.95rem', md: '0.875rem' },
                                                        lineHeight: { xs: 1.4, md: 1.43 }
                                                    }
                                                }
                                            })
                                    ),
                                    React.createElement('span', {
                                        style: {
                                            position: 'absolute',
                                            right: 16,
                                            bottom: 10,
                                            fontSize: 13,
                                            color: '#888',
                                            background: '#fafdff',
                                            padding: '0 6px'
                                        }
                                    }, `${bytesLen(output)} bytes`),

                                    // 이미지 미리보기 및 다운로드 버튼
                                    (() => {
                                        if (dataFormat === 'binary' && binaryFormat === 'image' && imageInfo) {
                                            return React.createElement(Box, { sx: { mt: 2, mb: 2, textAlign: 'center' } },
                                                React.createElement(Typography, { variant: "subtitle2", sx: { mb: 1 } }, `${t('imageViewLabel')} (${imageInfo.mime})`),
                                                React.createElement('img', {
                                                    src: imageInfo.src,
                                                    alt: "Decoded Image",
                                                    style: { maxWidth: '100%', maxHeight: 300, borderRadius: 8, border: '1px solid #eee', background: '#fff', display: 'block', margin: '0 auto 12px auto' }
                                                }),
                                                React.createElement(
                                                    MaterialUI.Button,
                                                    {
                                                        variant: "contained",
                                                        color: "primary",
                                                        size: "small",
                                                        startIcon: React.createElement("span", { className: "material-icons" }, "download"),
                                                        onClick: () => {
                                                            const a = document.createElement('a');
                                                            a.href = imageInfo.src;
                                                            a.download = `decoded_image.${imageInfo.ext || 'png'}`;
                                                            document.body.appendChild(a);
                                                            a.click();
                                                            document.body.removeChild(a);

                                                            // 저장 완료 토스트
                                                            showToast(t('imageSaveSuccess'), 'success');
                                                        },
                                                        sx: { mt: 1 }
                                                    },
                                                    "이미지 저장"
                                                )
                                            );
                                        }
                                        return null;
                                    })()
                                ),

                                // beautify / syntax checks
                                (dataFormat === 'json' || dataFormat === 'xml') && beautified &&
                                    React.createElement(Box, { sx: { mt: 2 } },
                                        React.createElement(Typography, { variant: "subtitle1", sx: { mb: 1, fontWeight: 'bold' } },
                                            t('beautifyLabel') + (syntaxError ? ' (Syntax Error)' : '')
                                        ),
                                        renderBeautifiedWithError(beautified, dataFormat, syntaxErrorLine)
                                    ),

                                // CBOR Diagnostic Notation 결과
                                dataFormat === 'binary' && binaryFormat === 'cbor' && cborDiagnostic && React.createElement(Box, { sx: { mt: 2 } },
                                    React.createElement(Typography, { variant: "subtitle1", sx: { mb: 1, fontWeight: 'bold' } },
                                        t('cborDiagnosticNotation')
                                    ),
                                    React.createElement(Box, {
                                        sx: {
                                            position: 'relative',
                                            border: '1px solid #e0e0e0',
                                            borderRadius: 1,
                                            backgroundColor: '#f8f9fa'
                                        }
                                    },
                                        React.createElement(Box, {
                                            sx: {
                                                position: 'absolute',
                                                top: 8,
                                                right: 8,
                                                zIndex: 1,
                                                display: 'flex',
                                                gap: 1
                                            }
                                        },
                                            React.createElement(Tooltip, {
                                                title: "CBOR 진단 표기 결과 복사"
                                            },
                                                React.createElement(
                                                    'span',
                                                    { style: { display: 'inline-block' } },
                                                    React.createElement(IconButton, {
                                                        size: "small",
                                                        disabled: !cborDiagnostic,
                                                        onClick: async () => {
                                                            if (!cborDiagnostic) return;
                                                            try {
                                                                await navigator.clipboard.writeText(cborDiagnostic);
                                                                showToast('CBOR 결과가 복사되었습니다!', 'success');
                                                            } catch (err) {
                                                                showToast('복사에 실패했습니다.', 'error');
                                                            }
                                                        }
                                                    },
                                                        React.createElement("span", { className: "material-icons", style: { fontSize: 18 } }, "content_copy")
                                                    )
                                                )
                                            ),
                                            React.createElement(Tooltip, {
                                                title: "CBOR 진단 표기 결과를 파일로 저장"
                                            },
                                                React.createElement(
                                                    'span',
                                                    { style: { display: 'inline-block' } },
                                                    React.createElement(IconButton, {
                                                        size: "small",
                                                        disabled: !cborDiagnostic,
                                                        onClick: () => {
                                                            if (!cborDiagnostic) return;
                                                            try {
                                                                const success = downloadTextFile(cborDiagnostic, 'cbor_diagnostic_result.txt');
                                                                if (success) {
                                                                    showToast('CBOR 결과가 파일로 저장되었습니다!', 'success');
                                                                } else {
                                                                    showToast('파일 저장에 실패했습니다.', 'error');
                                                                }
                                                            } catch (error) {
                                                                showToast('파일 저장에 실패했습니다.', 'error');
                                                            }
                                                        }
                                                    },
                                                        React.createElement("span", { className: "material-icons", style: { fontSize: 18 } }, "download")
                                                    )
                                                )
                                            )
                                        ),
                                        React.createElement(TextField, {
                                            label: "결과",
                                            value: cborDiagnostic,
                                            variant: "outlined",
                                            fullWidth: true,
                                            multiline: true,
                                            rows: 8,
                                            InputProps: { readOnly: true },
                                            sx: {
                                                '& .MuiOutlinedInput-root': {
                                                    fontFamily: 'monospace',
                                                    fontSize: '14px',
                                                    backgroundColor: '#ffffff'
                                                }
                                            }
                                        })
                                    )
                                )
                            ),

                            // ----------------- 인코딩 탭 -----------------
                            tab === 1 && React.createElement(Box, null,
                                React.createElement(Typography, { variant: "body2", color: "textSecondary", align: "center", style: { marginBottom: 16 } },
                                    t('encodeDescription')
                                ),
                                // 입력 초기화 및 파일 로드 버튼
                                React.createElement(Box, { sx: { textAlign: 'right', mb: 1, display: 'flex', justifyContent: 'flex-end', gap: 1 } },
                                    React.createElement(
                                        MaterialUI.Button,
                                        {
                                            variant: "outlined",
                                            color: "primary",
                                            size: "small",
                                            startIcon: React.createElement("span", { className: "material-icons" }, "upload_file"),
                                            onClick: () => handleFileSelect(setEncodeInput)
                                        },
                                        "파일 로드"
                                    ),
                                    React.createElement(
                                        MaterialUI.Button,
                                        {
                                            variant: "outlined",
                                            color: "secondary",
                                            size: "small",
                                            startIcon: React.createElement("span", { className: "material-icons" }, "clear"),
                                            onClick: () => setEncodeInput(''),
                                            disabled: !encodeInput
                                        },
                                        "입력 초기화"
                                    )
                                ),
                                // 1. 인코딩 입력 (드래그앤드롭 지원 + 드래그오버 UI)
                                React.createElement(Box, {
                                    sx: { position: 'relative', mb: 3, borderRadius: 2 },
                                    onDrop: (e) => handleFileDrop(e, setEncodeInput).finally(() => setIsDragOverEncode(false)),
                                    onDragOver: (e) => { e.preventDefault(); e.stopPropagation(); setIsDragOverEncode(true); },
                                    onDragLeave: (e) => { e.preventDefault(); e.stopPropagation(); setIsDragOverEncode(false); }
                                },
                                    React.createElement(TextField, {
                                        label: "일반 텍스트 입력",
                                        variant: "outlined",
                                        fullWidth: true,
                                        multiline: true,
                                        rows: 12,
                                        value: encodeInput,
                                        onChange: e => setEncodeInput(e.target.value),
                                        placeholder: t('encodeInputPlaceholder'),
                                        InputLabelProps: { shrink: true },
                                        inputRef: encodeInputRef,
                                        inputProps: {
                                            onDrop: (e) => handleFileDrop(e, setEncodeInput).finally(() => setIsDragOverEncode(false)),
                                            onDragOver: (e) => { e.preventDefault(); e.stopPropagation(); setIsDragOverEncode(true); },
                                            onDragLeave: (e) => { e.preventDefault(); e.stopPropagation(); setIsDragOverEncode(false); }
                                        },
                                        sx: {
                                            marginBottom: '20px',
                                            background: isDragOverEncode ? "#e3f2fd" : "#fafdff",
                                            borderRadius: 2,
                                            transition: "background 0.2s"
                                        }
                                    }),
                                    isDragOverEncode && React.createElement('div', {
                                        style: {
                                            pointerEvents: 'none',
                                            position: 'absolute',
                                            top: 0,
                                            left: 0,
                                            right: 0,
                                            bottom: 0,
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            borderRadius: 8,
                                            border: '2.5px dashed #1976d2',
                                            background: 'rgba(25, 118, 210, 0.10)',
                                            zIndex: 10,
                                            transition: "border 0.2s, background 0.2s",
                                            boxSizing: 'border-box'
                                        }
                                    },
                                        React.createElement('div', {
                                            style: {
                                                color: '#1976d2',
                                                fontWeight: 600,
                                                fontSize: 20,
                                                background: 'rgba(255,255,255,0.85)',
                                                borderRadius: 6,
                                                padding: '18px 36px',
                                                boxShadow: '0 2px 12px 0 rgba(25,118,210,0.08)',
                                                display: 'flex',
                                                alignItems: 'center',
                                                gap: 10
                                            }
                                        },
                                            React.createElement("span", { className: "material-icons", style: { fontSize: 28, marginRight: 8 } }, "file_upload"),
                                            "여기에 파일을 드롭하면 내용이 입력됩니다"
                                        )
                                    ),
                                    React.createElement('span', {
                                        style: {
                                            position: 'absolute',
                                            right: 16,
                                            bottom: 10,
                                            fontSize: 13,
                                            color: '#888',
                                            background: '#fafdff',
                                            padding: '0 6px'
                                        }
                                    }, `${bytesLen(encodeInput)} bytes`)
                                ),
                                // 인코딩 알고리즘 리스트 (레지스트리 기반)
                                React.createElement(Box, { sx: { mb: 1 } },
                                    React.createElement(Typography, {
                                        variant: "subtitle2",
                                        sx: { display: 'flex', alignItems: 'center', fontWeight: 700, color: 'primary.main' }
                                    },
                                        React.createElement("span", { className: "material-icons", style: { fontSize: 18, marginRight: 6 } }, "tune"),
                                        "인코딩 방식 선택"
                                    )
                                ),
                                React.createElement(Box, { sx: { mb: 2, display: 'flex', flexWrap: 'wrap', gap: 1 } },
                                    encoderLabels.map(type =>
                                        React.createElement(Chip, {
                                            key: type,
                                            label: type,
                                            size: "small",
                                            variant: "outlined",
                                            sx: {
                                                mr: 1, mb: 1,
                                                borderColor: encodeType === type ? 'primary.main' : '#e0e0e0',
                                                color: encodeType === type ? 'primary.main' : 'text.secondary',
                                                bgcolor: 'transparent',
                                                cursor: 'pointer',
                                                '&:hover': { bgcolor: '#fafafa' }
                                            },
                                            clickable: true,
                                            onClick: () => setEncodeType(type)
                                        })
                                    )
                                ),
                                // 선택된 인코딩 설명 (outlined Alert 스타일)
                                React.createElement(MaterialUI.Alert, {
                                    severity: "info",
                                    variant: "outlined",
                                    sx: {
                                        mb: 2,
                                        display: 'flex',
                                        alignItems: 'center',
                                        borderWidth: 1.5,
                                        borderColor: '#1976d2',
                                        color: '#1976d2',
                                        backgroundColor: 'transparent',
                                        borderRadius: 2
                                    },
                                    icon: React.createElement("span", { className: "material-icons", style: { color: '#1976d2' } }, "info")
                                },
                                    React.createElement(Box, { sx: { display: 'flex', flexDirection: 'column' } },
                                        React.createElement(Typography, { variant: "body2", sx: { fontWeight: 700 } }, t('algorithmDescription')),
                                        React.createElement(Typography, { variant: "caption" }, Codecs.getDescriptionByLabel(encodeType))
                                    )
                                ),

                                // 결과 복사
                                React.createElement(Box, { sx: { mb: 2, textAlign: 'right' } },
                                    React.createElement(
                                        Tooltip,
                                        { title: "인코딩 결과 복사" },
                                        React.createElement(
                                            'span', // Add span wrapper
                                            { style: { display: 'inline-block' } },
                                            React.createElement(
                                                MaterialUI.Button,
                                                {
                                                    size: "small",
                                                    color: "primary",
                                                    variant: "outlined",
                                                    startIcon: React.createElement("span", { className: "material-icons" }, "content_copy"),
                                                    onClick: async () => {
                                                        if (!encodeResult) return;
                                                        
                                                        // 바이너리 데이터 검사
                                                        if (isBinaryString(encodeResult, 0.1)) {
                                                            showToast(t('binaryNotCopyable'), 'error');
                                                            return;
                                                        }
                                                        
                                                        try {
                                                            await navigator.clipboard.writeText(encodeResult);
                                                            showToast(t('copySuccess'), 'success');
                                                        } catch {
                                                            showToast(t('copyError'), 'error');
                                                        }
                                                    },
                                                    sx: { verticalAlign: 'middle', mr: 1 },
                                                    disabled: !encodeResult
                                                },
                                                t('copyButton')
                                            )
                                        )
                                    ),
                                    React.createElement(
                                        Tooltip,
                                        { title: "인코딩 결과를 파일로 저장" },
                                        React.createElement(
                                            'span', // Add span wrapper
                                            { style: { display: 'inline-block' } },
                                            React.createElement(
                                                MaterialUI.Button,
                                                {
                                                    size: "small",
                                                    color: "secondary",
                                                    variant: "outlined",
                                                    startIcon: React.createElement("span", { className: "material-icons" }, "download"),
                                                    onClick: () => {
                                                        if (!encodeResult) return;
                                                        try {
                                                            const encodingType = encodeType.toLowerCase().replace(/[^a-z0-9]/g, '_');
                                                            let filename, success;
                                                            
                                                            // CBOR의 경우 바이너리 파일로 저장
                                                            if (encodeType === 'CBOR') {
                                                                filename = `encoded_${encodingType}_result.cbor`;
                                                                success = downloadBinaryFile(encodeResult, filename);
                                                            } else {
                                                                // 다른 인코딩은 텍스트 파일로 저장
                                                                filename = `encoded_${encodingType}_result.txt`;
                                                                success = downloadTextFile(encodeResult, filename);
                                                            }
                                                            
                                                            if (success) {
                                                                showToast(t('downloadSuccess'), 'success');
                                                            } else {
                                                                showToast(t('downloadError'), 'error');
                                                            }
                                                        } catch (error) {
                                                            showToast(t('downloadError'), 'error');
                                                        }
                                                    },
                                                    sx: { verticalAlign: 'middle' },
                                                    disabled: !encodeResult
                                                },
                                                t('downloadButton')
                                            )
                                        )
                                    )
                                ),
                                React.createElement(TextField, {
                                    label: t('encodeResultLabel'),
                                    variant: "outlined",
                                    fullWidth: true,
                                    multiline: true,
                                    rows: 12,
                                    value: encodeResult,
                                    InputLabelProps: { shrink: true },
                                    style: { marginBottom: '20px', background: "#fafdff" },
                                    InputProps: { readOnly: true }
                                }),
                                
                                // CBOR 인코딩 시 hex 결과 표시
                                encodeType === 'CBOR' && encodeHexResult ? React.createElement(Box, { sx: { mb: 2 } },
                                    React.createElement(Box, { sx: { mb: 1, textAlign: 'right' } },
                                        React.createElement(
                                            Tooltip,
                                            { title: "Hex 결과 복사" },
                                            React.createElement(
                                                MaterialUI.Button,
                                                {
                                                    size: "small",
                                                    color: "secondary",
                                                    variant: "outlined",
                                                    startIcon: React.createElement("span", { className: "material-icons" }, "content_copy"),
                                                    onClick: async () => {
                                                        if (!encodeHexResult) return;
                                                        try {
                                                            await navigator.clipboard.writeText(encodeHexResult);
                                                            showToast(t('copySuccess'), 'success');
                                                        } catch {
                                                            showToast(t('copyError'), 'error');
                                                        }
                                                    },
                                                    sx: { verticalAlign: 'middle', mr: 1 },
                                                    disabled: !encodeHexResult
                                                },
                                                "Hex 복사"
                                            )
                                        ),
                                        React.createElement(
                                            Tooltip,
                                            { title: "Hex 결과를 텍스트 파일로 저장" },
                                            React.createElement(
                                                MaterialUI.Button,
                                                {
                                                    size: "small",
                                                    color: "secondary",
                                                    variant: "outlined",
                                                    startIcon: React.createElement("span", { className: "material-icons" }, "download"),
                                                    onClick: () => {
                                                        if (!encodeHexResult) return;
                                                        try {
                                                            const success = downloadTextFile(encodeHexResult, 'cbor_hex_result.txt');
                                                            if (success) {
                                                                showToast(t('downloadSuccess'), 'success');
                                                            } else {
                                                                showToast(t('downloadError'), 'error');
                                                            }
                                                        } catch (error) {
                                                            showToast(t('downloadError'), 'error');
                                                        }
                                                    },
                                                    sx: { verticalAlign: 'middle' },
                                                    disabled: !encodeHexResult
                                                },
                                                "Hex 저장"
                                            )
                                        )
                                    ),
                                    React.createElement(TextField, {
                                        label: "Hex 결과",
                                        variant: "outlined",
                                        fullWidth: true,
                                        multiline: true,
                                        rows: 6,
                                        value: encodeHexResult,
                                        InputLabelProps: { shrink: true },
                                        style: { marginBottom: '20px', background: "#fff8e1" },
                                        InputProps: { readOnly: true }
                                    })
                                ) : null,
                                
                            ),
                            
                            // 페이지 하단 언어 선택
                            React.createElement(Box, { 
                                sx: { 
                                    display: 'flex', 
                                    justifyContent: 'center', 
                                    mt: 4,
                                    mb: 2,
                                    pt: 3,
                                    borderTop: '1px solid #e0e0e0'
                                } 
                            },
                                React.createElement(MaterialUI.FormControl, { 
                                    sx: { 
                                        minWidth: { xs: 140, md: 120 },
                                        '& .MuiInputLabel-root': {
                                            fontSize: { xs: '0.9rem', md: '0.875rem' }
                                        },
                                        '& .MuiSelect-select': {
                                            padding: { xs: '8px 32px 8px 12px', md: '6px 24px 6px 8px' }
                                        }
                                    } 
                                },
                                    React.createElement(MaterialUI.InputLabel, { 
                                        id: "language-select-label",
                                        sx: { fontSize: { xs: '0.9rem', md: '0.875rem' } }
                                    }, t('languageLabel')),
                                    React.createElement(MaterialUI.Select, {
                                        labelId: "language-select-label",
                                        value: language,
                                        onChange: (event) => setLanguage(event.target.value),
                                        label: t('languageLabel'),
                                        size: "small",
                                        variant: "outlined",
                                        sx: { 
                                            fontSize: { xs: '0.9rem', md: '0.875rem' },
                                            '& .MuiSelect-icon': {
                                                fontSize: '1.2rem'
                                            }
                                        }
                                    },
                                        React.createElement(MaterialUI.MenuItem, { value: "ko", sx: { fontSize: '0.875rem' } }, 
                                            React.createElement(Box, { sx: { display: 'flex', alignItems: 'center', gap: 1 } },
                                                React.createElement('img', { 
                                                    src: 'https://flagcdn.com/16x12/kr.png',
                                                    alt: '한국',
                                                    style: { width: '16px', height: '12px' }
                                                }),
                                                React.createElement('span', null, t('korean'))
                                            )
                                        ),
                                        React.createElement(MaterialUI.MenuItem, { value: "en", sx: { fontSize: '0.875rem' } },
                                            React.createElement(Box, { sx: { display: 'flex', alignItems: 'center', gap: 1 } },
                                                React.createElement('img', { 
                                                    src: 'https://flagcdn.com/16x12/us.png',
                                                    alt: '미국',
                                                    style: { width: '16px', height: '12px' }
                                                }),
                                                React.createElement('span', null, t('english'))
                                            )
                                        )
                                    )
                                )
                            ),
                            
                            // 전역 Snackbar
                            React.createElement(
                                MaterialUI.Portal,
                                { container: document.body },
                                React.createElement(
                                    MaterialUI.Snackbar,
                                    {
                                        open: toast.open,
                                        autoHideDuration: 1000,
                                        onClose: handleToastClose,
                                        anchorOrigin: { vertical: 'bottom', horizontal: 'center' }
                                    },
                                    React.createElement(
                                        MaterialUI.Alert,
                                        { onClose: handleToastClose, severity: toast.severity, sx: { width: '100%' } },
                                        toast.message
                                    )
                                )
                            )
                        )
                    )
                )
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(EncoderDecoderTabs));

        // base64 helper (기존 함수 유지)
        function binaryStringToBase64(binStr) {
            const bytes = Uint8Array.from(Array.from(binStr).map(ch => ch.charCodeAt(0)));
            let binary = '';
            bytes.forEach(b => binary += String.fromCharCode(b));
            return btoa(binary);
        }
    </script>
</body>
</html>
</html>